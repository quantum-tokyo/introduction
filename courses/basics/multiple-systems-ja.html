
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>複数システム &#8212; Quantum Tokyo</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'courses/basics/multiple-systems-ja';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Quantum Tokyo - Home"/>
    <img src="../../_static/logo.png" class="logo__image only-dark pst-js-only" alt="Quantum Tokyo - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Quantum Tokyo へようこそ
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">学習コンテンツ</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../get_started.html">Qiskit の始め方</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iqp_documents.html">IBM Quantum Plaform 教材 日本語訳</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ibm_research_blog.html">IBM Research Blog 日本語版</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qiskit_textbook_ja.html">Qiskitテキストブック 日本語版</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qiskit_textbook_new_ja.html">新版 Qiskitテキストブック 日本語版 (Qiskitコース)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qiskit_documents_ja.html">Qiskitドキュメント・チュートリアル 日本語版リンク集</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_challenge_ja.html">IBM Quantum Challenge 一覧</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qgss_ja.html">Qiskit Global Summer School （Qiskit夏の学校） 資料 日本語版</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_tokyo_materials.html">Quantum Tokyo 過去イベント資料</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../events.html">Qiskitコミュニティー関連イベント案内</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools.html">その他： IBM Quantum の便利なツール</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/quantum-tokyo/introduction" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/quantum-tokyo/introduction/issues/new?title=Issue%20on%20page%20%2Fcourses/basics/multiple-systems-ja.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/courses/basics/multiple-systems-ja.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>複数システム</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">はじめに</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">1. 古典情報<a id="multiple-systems-classical-info"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">1.1 デカルト積による古典的状態 <a id="multiple-systems-classical-state-sets"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">状態を文字列として表す</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">1.2 確率的状態 <a id="multiple-systems-probabilistic"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">デカルト積の状態集合の順序付け</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">2 つのシステムの独立性</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">ベクトルのテンソル積</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">3 つ以上のシステムの独立性とテンソル積</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">1.3 確率的状態の測定 <a id="multiple-systems-probabilistic-measurement"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">部分測定</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">1.4 確率的状態の演算  <a id="multiple-systems-probabilistic-operations"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">独立した演算</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">行列のテンソル積</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">独立した演算（続き）</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">2. 量子情報 <a id="multiple-systems-quantum-info"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">2.1 量子状態<a id="multiple-systems-quantum-states"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">量子状態ベクトルのテンソル積</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">エンタングル状態</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">ベル状態</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ghz-w">GHZ と W 状態</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">追加の例</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">2.2 量子状態の測定 <a id="multiple-systems-quantum-measurements"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id24">2 つのシステムの部分測定</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">縮約量子状態について</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id26">3 つ以上のシステムの部分測定</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id27">2.3 ユニタリー演算 <a id="multiple-systems-quantum-operations"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id28">個々のシステムで独立して実行されるユニタリー演算</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id29">スワップ演算</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id30">制御ユニタリー演算</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#qiskit">3. Qiskit コード例</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id31">3.1 テンソル積</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id32">3.2 部分測定</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>複数システム<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<section id="id2">
<h2>はじめに<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>この授業では、 <em>複数の</em> のシステムが考えられる場合の量子情報の基礎に焦点を当てます。このような状況は、古典的、量子的を問わず、情報処理において自然に発生します。大きな情報伝達系は、ビットや量子ビットのような小さな系の集まりを使って、最も簡単に構築されることが多いです。</p>
<p>この授業では、複数のシステムをまとめて、あたかも1つの合成システムを <em>共</em> に形成しているかのように見ることができるという、シンプルでありながら非常に重要なアイデアを紹介します。実際、この考え方は、複数の系に対して、量子状態、量子計測、量子演算がどのように行われるかを説明することに直結しています。</p>
<p>しかし、複数の量子システムを理解するためには、それらをまとめて一つのシステムとして見るだけでは不十分です。例えば、ある特定の量子状態にある複数の量子システムを用意し、そのうちの1つ（または <a class="reference internal" href="#gloss:proper-subset"><span class="xref myst">適切な部分集合</span></a> ）を測定することがあります。一般に、このような測定は残りのシステムの状態に影響を与えるため、量子アルゴリズムやプロトコルを解析する際には、その方法を正確に理解することが重要です。また、複数のシステム間の <em>相関</em> 関係、特に <em>エンタングルメント</em> と呼ばれる相関関係を理解することも、量子情報・量子計算において重要です。</p>
</section>
<section id="id3">
<h2>1. 古典情報<a id="multiple-systems-classical-info"></a><a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>前回の授業と同様に、古典的な情報の議論から始めます。今回も、確率論的な記述と量子論的な記述は数学的に類似しており、古典的な情報という身近な設定で数学がどのように機能するかを認識することは、量子情報がなぜそのような方法で記述されるのかを理解する上で有用です。</p>
<section id="id4">
<h3>1.1 デカルト積による古典的状態 <a id="multiple-systems-classical-state-sets"></a><a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>ここでは、非常に基本的なレベルから、複数のシステムの古典的な状態について説明します。簡単のために、まず2つのシステムだけを取り上げ、その後2つ以上のシステムに一般化することにします。</p>
<p>具体的には、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が古典的な状態の集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> を持つシステムで、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が古典的な状態の集合  <span class="math notranslate nohighlight">\(\Gamma\)</span> を持つ第二のシステムであるとします。前回と同じく、これらの集合を <em>古典的な状態の集合</em> と呼んでいるので、 <span class="math notranslate nohighlight">\(\Sigma\)</span> と <span class="math notranslate nohighlight">\(\Gamma\)</span> はともに有限で空でないという前提です。 <span class="math notranslate nohighlight">\(\Sigma = \Gamma\)</span> ということもあり得ますが、必ずしもそうとは限りませんので、それとは別に、これらの集合を指す名前を変えておくと、わかりやすくなります。</p>
<p>ここで、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の2つのシステムを、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を左、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> を右にして並べるとします。この2つのシステムは、あたかも1つのシステムを形成しているかのように見ることができ、これを好みによって  <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> または <span class="math notranslate nohighlight">\(\mathsf{XY}\)</span> と表記することができます。</p>
<p>この合成システム <span class="math notranslate nohighlight">\(( \mathsf{X},\mathsf{Y})\)</span> について、”その古典状態は何か “という自然な疑問が湧きます。</p>
<p>答えは、 <span class="math notranslate nohighlight">\(( \mathsf{X},\mathsf{Y})\)</span> の古典的な状態の集合は、 <span class="math notranslate nohighlight">\(\Sigma\)</span> と <span class="math notranslate nohighlight">\(\Gamma\)</span> の <em><a class="reference internal" href="#gloss:cartesian-product"><span class="xref myst">デカルト積(直積)</span></a></em> であり、次のように定義される集合であることです。</p>
<div class="math notranslate nohighlight">
\[
  \Sigma\times\Gamma = \bigl\{(a,b)\,:\,a\in\Sigma\;\text{and}\;b\in\Gamma\bigr\}.
\]</div>
<p>デカルト積とは、簡単に言えば、ある集合の要素とある集合の要素を合わせて、あたかも一つの集合の一つの要素であるかのように捉える数学的概念にほかなりません。</p>
<p>このとき、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> が古典的な状態 <span class="math notranslate nohighlight">\((a,b)\in\Sigma\times\Gamma\)</span>  にあるというのは、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が古典状態 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> にあり、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が古典状態 <span class="math notranslate nohighlight">\(b\in\Gamma\)</span> にあることを意味します。 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の古典状態が <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> 、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の古典状態が <span class="math notranslate nohighlight">\(b\in\Gamma\)</span> であれば、合成システム <span class="math notranslate nohighlight">\(( \mathsf{X},\mathsf{Y})\)</span> の古典状態は <span class="math notranslate nohighlight">\((a,b)\)</span> となります。</p>
<p>2つ以上のシステムでは、状況は自然な形で一般化されます。ここで、 <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> がそれぞれ任意の正の整数 <span class="math notranslate nohighlight">\(n\)</span> に対して古典状態の集合 <span class="math notranslate nohighlight">\(\Sigma_1, \ldots,\Sigma_n\)</span> を持つシステムであるとします。 <span class="math notranslate nohighlight">\(n\)</span> 個のタプル <span class="math notranslate nohighlight">\((\mathsf{X}_1,\ldots,\mathsf{X}_n)\)</span> の古典状態の集合は、単一の合成システムとして表され、以下のようなデカルト積となります。</p>
<div class="math notranslate nohighlight">
\[
  \Sigma_1\times\cdots\times\Sigma_n
  = \bigl\{(a_1,\ldots,a_n)\,:\,
  a_1\in\Sigma_1,\:\ldots,\:a_n\in\Sigma_n\bigr\}.
\]</div>
<section id="id5">
<h4>状態を文字列として表す<a class="headerlink" href="#id5" title="Link to this heading">#</a></h4>
<p>古典状態 <span class="math notranslate nohighlight">\((a_1,\ldots,a_n)\)</span> を <em><a class="reference internal" href="#gloss:string"><span class="xref myst">文字列</span></a></em> <span class="math notranslate nohighlight">\(a_1\cdots a_n\)</span> として書くと、特に古典状態の集合 <span class="math notranslate nohighlight">\(\Sigma_1,\ldots,\Sigma_n\)</span> が <em>記号</em> または <em>文字</em> の集合と関連する（非常に典型的な）状況で、簡潔さのためにしばしば便利です。</p>
<p>実際、コンピューター サイエンスの根本的に重要な概念である文字列の概念は、デカルト積によって数学的に形式化されています。  <em>アルファベット</em> という用語は、通常、文字列を形成するために使用される記号の集合を指すために使用されますが、アルファベットの数学的な定義は、古典的な状態の集合の定義とまったく同じです。つまり、有限で空でない集合です。</p>
<p>たとえば、 <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_\mathrm{10}\)</span> がビットであると仮定すると、これらのシステムの古典的な状態の集合はすべて同じになります。</p>
<div class="math notranslate nohighlight">
\[
  \Sigma_1 = \Sigma_2 = \cdots = \Sigma_{10} = \{0,1\}
\]</div>
<p>(集合 <span class="math notranslate nohighlight">\(\{0,1\}\)</span> は、一般に <em>バイナリーアルファベット</em> と呼ばれます。 ) このとき、合成システム <span class="math notranslate nohighlight">\((\mathsf{X}_1,\ldots,\mathsf{X}_\mathrm{10})\)</span> の <span class="math notranslate nohighlight">\(2^{10} = 1024\)</span> 個の古典的な集合があり、これらは以下の集合の要素です。</p>
<div class="math notranslate nohighlight">
\[
  \Sigma_1\times\Sigma_2\times\cdots\times\Sigma_{10} = \{0,1\}^{10}.
\]</div>
<p>これらの古典的な状態を文字列として記述すると、次のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{array}{c}
  0000000000\\
  0000000001\\
  0000000010\\
  0000000011\\
  0000000100\\
  \vdots\\[1mm]
  1111111111
  \end{array}.
\end{split}\]</div>
<p>たとえば、古典状態 <span class="math notranslate nohighlight">\(0001010000\)</span> の場合、<span class="math notranslate nohighlight">\(\mathsf{X}_4\)</span> と <span class="math notranslate nohighlight">\(\mathsf{X}_6\)</span> が状態 <span class="math notranslate nohighlight">\(1\)</span> にあるのに対し、他のすべてのシステムは状態 <span class="math notranslate nohighlight">\(0\)</span> にあることがわかります。</p>
</section>
</section>
<section id="id6">
<h3>1.2 確率的状態 <a id="multiple-systems-probabilistic"></a><a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>前のレッスンから、<em>確率的状態は</em>確率をシステムの各古典的状態に関連付けられたことを思い出してください。したがって、複数のシステムの確率的状態は (それらが 1 つのシステムを形成しているかのように集合的に見た場合) 、個々のシステムの古典的な状態の集合のデカルト積の各要素に確率が関連付けられます。</p>
<p>たとえば、<span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が両方ともビットであり、対応する古典的な状態の集合がそれぞれ <span class="math notranslate nohighlight">\(\Sigma = \{0,1\}\)</span> および <span class="math notranslate nohighlight">\(\Gamma = \{0,1\}\)</span> であるとします。  <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> のペアの確率的状態を次に示します。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{aligned}
    \operatorname{Pr}\bigl( (\mathsf{X},\mathsf{Y}) = (0,0)\bigr)
    &amp; = \frac{1}{2} \\[2mm]
    \operatorname{Pr}\bigl( (\mathsf{X},\mathsf{Y}) = (0,1)\bigr)
    &amp; = 0\\[2mm]
    \operatorname{Pr}\bigl( (\mathsf{X},\mathsf{Y}) = (1,0)\bigr)
    &amp; = 0\\[2mm]
    \operatorname{Pr}\bigl( (\mathsf{X},\mathsf{Y}) = (1,1)\bigr)
    &amp; = \frac{1}{2}
  \end{aligned}
\end{split}\]</div>
<p>この確率的状態は、<span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の両方がランダムなビットである状態です — それぞれが確率 1/2 で 0 で、確率 1/2 で 1 です — しかし、2 つのビットの古典的な状態は常に同じです。これは、これらのシステム間の<em>相関関係</em>の例です。</p>
<section id="id7">
<h4>デカルト積の状態集合の順序付け<a class="headerlink" href="#id7" title="Link to this heading">#</a></h4>
<p>システムの確率的な状態は、確率ベクトルで表されます。これは、対象となるシステムの基礎となる古典的な状態の集合に対応するように配置されたインデックスを持つ列ベクトルです。</p>
<p>複数のシステムで同じ状況が発生します。複数のシステムの確率的状態をデカルト積として表すには、積の要素の順序を決定する必要があります。システム <span class="math notranslate nohighlight">\(\mathsf{X}, \mathsf{Y}\)</span> の個々の古典的な状態集合 <span class="math notranslate nohighlight">\(\Sigma, \Gamma\)</span> が既に順序付けられていると仮定すると、これを行うための簡単な規則があります: <em>アルファベット順</em> です。より正確には、各 <span class="math notranslate nohighlight">\(n\)</span> -タプル (または、同等に、各文字列のシンボル) の要素は、 <em>左から右に大きくなる</em> ように並べられています。</p>
<p>たとえば、この規則に従って、デカルト積 <span class="math notranslate nohighlight">\(\{1,2,3\}\times\{0,1\}\)</span> は次のように並べられます。</p>
<div class="math notranslate nohighlight">
\[
  (1,0),\;
  (1,1),\;
  (2,0),\;
  (2,1),\;
  (3,0),\;
  (3,1).
\]</div>
<p><span class="math notranslate nohighlight">\(n\)</span> -タプルが文字列として記述され、このように順序付けられると、<span class="math notranslate nohighlight">\(\{0,1\}\times\{0,1\}\)</span> が <span class="math notranslate nohighlight">\(00, 01, 10, 11\)</span> として順序付けられ、集合 <span class="math notranslate nohighlight">\(\{0,1\}^{10}\)</span> は上で提案されたように並べられています。 <span class="math notranslate nohighlight">\(\{0, 1, \dots, 9\} \times \{0, 1, \dots, 9\}\)</span> が 0 から 99 までの数字として並べられていることもわかります。これは偶然ではないことに気付くかもしれません。今日の 10 進数システムは同じアルファベット順を使用しています。もちろん、ここで「アルファベット順」はより広い意味を持ち、数字記号の集まりを含む場合があります。</p>
<p>上記の 2 ビットの例に戻ると、確率的状態は次の確率ベクトルによって表されます (明確にするために、要素には明示的にラベルが付けられています)。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
    \frac{1}{2}\\[1mm]
    0\\[1mm]
    0\\[1mm]
    \frac{1}{2}
  \end{pmatrix}
  \begin{array}{l}
    \leftarrow \text{probability associated with state 00}\\[1mm]
    \leftarrow \text{probability associated with state 01}\\[1mm]
    \leftarrow \text{probability associated with state 10}\\[1mm]
    \leftarrow \text{probability associated with state 11}
  \end{array}
  \label{eq:correlatedbits} \tag{1}
\end{split}\]</div>
</section>
<section id="id8">
<h4>2 つのシステムの独立性<a class="headerlink" href="#id8" title="Link to this heading">#</a></h4>
<p>2つのシステムの確率的状態の特別なタイプは、システムが<em>独立である</em>というものです。直感的に言えば、2つのシステムが独立であるとは、どちらかのシステムの古典的状態を学習しても、もう一方のシステムに関連する確率に影響を与えないということです。つまり、一方のシステムの古典的状態を知ることは、他方のシステムの古典的状態について全く情報を与えないということです。</p>
<p>この概念を正確に定義するために、もう一度 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> がそれぞれ古典的な状態の集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> と <span class="math notranslate nohighlight">\(\Gamma\)</span> を持つシステムであると仮定します。これらのシステムが与えられた確率的状態に関して、次のような場合、両者は<em>独立</em>であるといいます。</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}((\mathsf{X},\mathsf{Y}) = (a,b))
  = \operatorname{Pr}(\mathsf{X} = a) \operatorname{Pr}(\mathsf{Y} = b)
  \tag{2}
\]</div>
<p>上記は、 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> と <span class="math notranslate nohighlight">\(b\in\Gamma\)</span> のすべての選択に対してです。</p>
<p>この条件を確率ベクトルで表現するために、与えられた確率的な状態 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> を確率ベクトルで記述すると、ディラック表記で次のように書きます。</p>
<div class="math notranslate nohighlight">
\[
\sum_{(a,b) \in \Sigma\times\Gamma} p_{ab} \vert a b\rangle.
\]</div>
<p>独立性の条件 <span class="math notranslate nohighlight">\((2)\)</span> は、以下のような2つの確率ベクトルが存在することと等価です。</p>
<div class="math notranslate nohighlight">
\[
\vert \phi \rangle = \sum_{a\in\Sigma} q_a \vert a \rangle
\quad\text{と}\quad
\vert \psi \rangle = \sum_{b\in\Gamma} r_b \vert b \rangle,
\tag{3}
\]</div>
<p>上記は、それぞれ <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の古典的な状態に関連する確率を表し、すべての <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> および <span class="math notranslate nohighlight">\(b\in\Gamma\)</span> に対して、</p>
<div class="math notranslate nohighlight">
\[
p_{ab} = q_a r_b
\tag{4}
\]</div>
<p>となります。</p>
<p>たとえば、ベクトルで表されるビット <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> のペアの確率的状態</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{6} \vert 00 \rangle
  + \frac{1}{12} \vert 01 \rangle
  + \frac{1}{2} \vert 10 \rangle
  + \frac{1}{4} \vert 11 \rangle
\]</div>
<p>は <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が独立したものです。具体的には、独立性に必要な条件は、以下の確率ベクトルに対して真です。</p>
<div class="math notranslate nohighlight">
\[
  \vert \phi \rangle = \frac{1}{4} \vert 0 \rangle + \frac{3}{4} \vert 1 \rangle
  \quad\text{と}\quad
  \vert \psi \rangle = \frac{2}{3} \vert 0 \rangle + \frac{1}{3} \vert 1 \rangle.
\]</div>
<p>たとえば、<span class="math notranslate nohighlight">\(00\)</span> の要素に一致させるには、<span class="math notranslate nohighlight">\(\frac{1}{6} = \frac{1}{4} \times \frac{2}{3}\)</span> が必要であり、実際にそうです。他の要素も同様の方法で確認できます。</p>
<p>一方、確率的状態 <span class="math notranslate nohighlight">\((1)\)</span> は、次のように記述できます。</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{2} \vert 00 \rangle + \frac{1}{2} \vert 11 \rangle,
  \tag{5}
\]</div>
<p>これは、システム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の間の独立性を表していません。これを主張する簡単な方法は次のとおりです。</p>
<p>上記の方程式 <span class="math notranslate nohighlight">\((3)\)</span> のように、 <span class="math notranslate nohighlight">\(a\)</span> と <span class="math notranslate nohighlight">\(b\)</span> のすべての選択に対して条件 <span class="math notranslate nohighlight">\((4)\)</span> を満たす確率ベクトル <span class="math notranslate nohighlight">\(\vert \phi\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> が存在すると仮定します。その場合、必然的に</p>
<div class="math notranslate nohighlight">
\[
  q_0 r_1 = \operatorname{Pr}\bigl((\mathsf{X},\mathsf{Y}) = (0,1)\bigr) = 0.
\]</div>
<p>となり、これは、 <span class="math notranslate nohighlight">\(q_0 = 0\)</span> または <span class="math notranslate nohighlight">\(r_1 = 0\)</span> のどちらかを意味します。これは、両方とも0でない場合、積 <span class="math notranslate nohighlight">\(q_0 r_1\)</span> が0にならないためです。このことから、 <span class="math notranslate nohighlight">\(q_0 r_0 = 0\)</span> （ <span class="math notranslate nohighlight">\(q_0=0\)</span> の場合）か <span class="math notranslate nohighlight">\(q_1 r_1 = 0\)</span> （ <span class="math notranslate nohighlight">\(r_1=0\)</span> の場合）のどちらかであることがわかります。しかし、  <span class="math notranslate nohighlight">\(q_0 r_0 = 1/2\)</span> と <span class="math notranslate nohighlight">\(q_1 r_1 = 1/2\)</span>  でなければならないので、どちらの等式も成り立たないことがわかります。したがって、独立に必要な性質を満たすベクトル <span class="math notranslate nohighlight">\(\vert\phi\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> は存在しません。</p>
<p>2つのシステム間の独立性を定義したので、今度は相関関係を<em>独立性の欠如</em>として正確に定義できるようになりました。例えば、ベクトル <span class="math notranslate nohighlight">\((5)\)</span> が表す確率的状態の2つのビットは独立ではないので、定義上、相関があることになります。</p>
</section>
<section id="id9">
<h4>ベクトルのテンソル積<a class="headerlink" href="#id9" title="Link to this heading">#</a></h4>
<p>今説明した独立の条件は、<em>テンソル積</em>の概念によってより簡潔に表現できます。これは非常に抽象的に定義され、さまざまな数学的構造に適用できる非常に一般的な概念ですが、当面の場合、単純で具体的な用語で定義できます。与えられた 2 つのベクトル</p>
<div class="math notranslate nohighlight">
\[
\vert \phi \rangle = \sum_{a\in\Sigma} \alpha_a \vert a \rangle
\quad\text{と}\quad
\vert \psi \rangle = \sum_{b\in\Gamma} \beta_b \vert b \rangle,
\]</div>
<p>のテンソル積 <span class="math notranslate nohighlight">\(\vert \phi \rangle \otimes \vert \psi \rangle\)</span> は、次のように定義される合成状態の集合 <span class="math notranslate nohighlight">\(\Sigma \times \Gamma\)</span> 上の新しいベクトルです。</p>
<div class="math notranslate nohighlight">
\[
  \vert \phi \rangle \otimes \vert \psi \rangle
  = \sum_{(a,b)\in\Sigma\times\Gamma} \alpha_a \beta_b \vert ab\rangle.
\]</div>
<p>同様に、ベクトル <span class="math notranslate nohighlight">\(\vert \pi \rangle = \vert \phi \rangle \otimes \vert \psi \rangle\)</span> は次の式で定義され、</p>
<div class="math notranslate nohighlight">
\[
\langle ab \vert \pi \rangle = \langle a \vert \phi \rangle \langle b \vert \psi \rangle
\]</div>
<p>は、すべての <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> と <span class="math notranslate nohighlight">\(b\in\Gamma\)</span> について真です。</p>
<p>ここで、合成システム <span class="math notranslate nohighlight">\((\mathsf{X}, \mathsf{Y})\)</span> の確率ベクトル <span class="math notranslate nohighlight">\(\vert \pi \rangle\)</span> がテンソル積として表現可能であることを要求するものとして、独立の条件を作り直すことができます。</p>
<div class="math notranslate nohighlight">
\[
  \vert \pi \rangle = \vert \phi \rangle \otimes \vert \psi \rangle
\]</div>
<p>サブシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> のそれぞれの確率ベクトル <span class="math notranslate nohighlight">\(\vert \phi \rangle\)</span> と <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> のこの状況では、 <span class="math notranslate nohighlight">\(\vert \pi \rangle\)</span> は<em>積状態</em>または<em>積ベクトル</em>であるといいます。</p>
<p>ケットののテンソル積を取るとき、しばしば ‘<span class="math notranslate nohighlight">\(\otimes\)</span>’ を省略します。たとえば、 <span class="math notranslate nohighlight">\(\vert \phi \rangle \otimes \vert \psi \rangle\)</span> ではなく、 <span class="math notranslate nohighlight">\(\vert \phi \rangle \vert \psi \rangle\)</span> と書きます。 この慣例は、テンソル積が、このコンテキストでは、2つのベクトルの積を取る最も自然な方法である、またはデフォルトの方法であるという考えを表しています。あまり一般的ではありませんが、<span class="math notranslate nohighlight">\(\vert \phi\otimes\psi\rangle\)</span> という表記も使用されることがあります。</p>
<p>デカルト積の要素の並び方にアルファベット規則を使用すると、2 つの列ベクトルのテンソル積について次の仕様が得られます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
  \alpha_1\\
  \vdots\\
  \alpha_m
  \end{pmatrix}
  \otimes
  \begin{pmatrix}
  \beta_1\\
  \vdots\\
  \beta_k
  \end{pmatrix}
  =
  \begin{pmatrix}
  \alpha_1 \beta_1\\
  \vdots\\
  \alpha_1 \beta_k\\
  \alpha_2 \beta_1\\
  \vdots\\
  \alpha_2 \beta_k\\
  \vdots\\
  \alpha_m \beta_1\\
  \vdots\\
  \alpha_m \beta_k
  \end{pmatrix}.
\end{split}\]</div>
<p>重要な余談ですが、標準基底ベクトルのテンソル積について、次のような書き方があります。</p>
<div class="math notranslate nohighlight">
\[
\vert a \rangle \otimes \vert b \rangle = \vert ab \rangle.
\]</div>
<p>あるいは、 <span class="math notranslate nohighlight">\((a,b)\)</span> を文字列ではなく、順序付きペアで書くと、次のようになります。</p>
<div class="math notranslate nohighlight">
\[
\vert a \rangle \otimes \vert b \rangle = \vert (a,b) \rangle,
\]</div>
<p>しかし、より一般的には以下のように書きます。</p>
<div class="math notranslate nohighlight">
\[
\vert a \rangle \otimes \vert b \rangle = \vert a,b \rangle
\]</div>
<p>数学の慣習にならい、明確さや曖昧さをもたらさない括弧は削除します。</p>
<p>2つのベクトルのテンソル積は、<em>双線形</em>という重要な性質を持っています。これは、もう一方の引数が固定されていると仮定して、2つの引数のそれぞれに対して個別に線形であることを意味します。<br>この性質は、以下の式で表すことができます。</p>
<ol class="arabic simple">
<li><p>最初の引数の線形性:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{aligned}
    \bigl(\vert\phi_1\rangle + \vert\phi_2\rangle\bigr)
    \otimes \vert\psi\rangle
    &amp; =
    \vert\phi_1\rangle \otimes \vert\psi\rangle
    +
    \vert\phi_2\rangle \otimes \vert\psi\rangle \\[1mm]
    \bigl(\alpha \vert \phi \rangle\bigr) \otimes
    \vert \psi \rangle
    &amp; =
    \alpha \bigl(\vert \phi \rangle \otimes
    \vert \psi \rangle \bigr)
  \end{aligned}
\end{split}\]</div>
<ol class="arabic simple">
<li><p>2 番目の引数の線形性:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{aligned}
    \vert \phi \rangle \otimes
    \bigl(\vert \psi_1 \rangle + \vert \psi_2 \rangle \bigr)
    &amp; =
    \vert \phi \rangle \otimes \vert \psi_1 \rangle +
    \vert \phi \rangle \otimes \vert \psi_2 \rangle\\[1mm]
    \vert \phi \rangle \otimes
    \bigl(\alpha \vert \psi \rangle \bigr)
    &amp; = \alpha \bigl(\vert\phi\rangle\otimes\vert\psi\rangle\bigr)
  \end{aligned}
\end{split}\]</div>
<p>これらの式のうち、2番目の式を考えると、スカラーはテンソル積の中で「自由に浮遊」していることがわかります。</p>
<div class="math notranslate nohighlight">
\[
\bigl(\alpha \vert \phi \rangle\bigr) \otimes \vert \psi \rangle
= \vert \phi \rangle \otimes \bigl(\alpha \vert \psi \rangle \bigr)
= \alpha \bigl(\vert \phi \rangle \otimes \vert \psi \rangle \bigr).
\]</div>
<p>したがって、このベクトルを指し示すために、単純に <span class="math notranslate nohighlight">\(\alpha\vert\phi\rangle\otimes\vert\psi\rangle\)</span> と書いても、あるいは <span class="math notranslate nohighlight">\(\alpha\vert\phi\rangle\vert\psi \rangle\)</span>  や<span class="math notranslate nohighlight">\(\alpha\vert\phi\otimes\psi\rangle\)</span> と書いても問題ありません。</p>
</section>
<section id="id10">
<h4>3 つ以上のシステムの独立性とテンソル積<a class="headerlink" href="#id10" title="Link to this heading">#</a></h4>
<p>独立性とテンソル積の概念は、3 つ以上のシステムに直接一般化できます。 <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> がそれぞれ古典的な状態集合 <span class="math notranslate nohighlight">\(\Sigma_1,\ldots,\Sigma_n\)</span> を持つ系である場合、組み合わせたシステム <span class="math notranslate nohighlight">\((\mathsf{X}_1,\ldots,\mathsf{X}_n)\)</span> の確率的状態は、関連する確率ベクトルが、 <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> の確率的状態を記述する確率ベクトル <span class="math notranslate nohighlight">\(\vert \phi_1 \rangle,\ldots,\vert \phi_n\rangle\)</span> に対して、以下のような形の場合、</p>
<div class="math notranslate nohighlight">
\[
  \vert \psi \rangle = \vert \phi_1 \rangle \otimes \cdots \otimes
  \vert \phi_n \rangle
\]</div>
<p><em>積状態<em>{nbsp}となります。</em></em></p>
<p>ここで、テンソル積の定義は自然な方法で一般化されます: ベクトル <span class="math notranslate nohighlight">\(\vert \psi \rangle = \vert \phi_1 \rangle \otimes \cdots \otimes \vert \phi_n \rangle\)</span> は次の式によって定義され、</p>
<div class="math notranslate nohighlight">
\[
  \langle a_1 \cdots a_n \vert \psi \rangle
  = \langle a_1 \vert \phi_1 \rangle \cdots
  \langle a_n \vert \phi_n \rangle
\]</div>
<p>これは、すべての <span class="math notranslate nohighlight">\(a_1\in\Sigma_1、\ldots a_n\in\Sigma_n\)</span> について真です。 3 つ以上のベクトルのテンソル積を定義する別の方法は、2 つのベクトルのテンソル積に関して再帰的に行われます。</p>
<div class="math notranslate nohighlight">
\[
  \vert \phi_1 \rangle \otimes \cdots \otimes
  \vert \phi_n \rangle
  =
  \bigl(\vert \phi_1 \rangle \otimes \cdots \otimes \vert \phi_{n-1}
  \rangle\bigr) \otimes \vert \phi_n \rangle,
\]</div>
<p>この時、 <span class="math notranslate nohighlight">\(n\geq 3\)</span> と仮定しています。</p>
<p>2 つのベクトルだけのテンソル積と同様に、3 つ以上のベクトルのテンソル積は、他のすべての引数が固定されていると仮定すると、各引数で個別に線形になります。この場合、3 つ以上のベクトルのテンソル積は<em>多重線形</em>であると言います。</p>
<p>2 つのシステムの場合と同様に、システム <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> が積状態にある場合、システムは<em>独立</em>していると言えますが、用語<em>相互に独立</em>しているという方がより正確です。<em>ペアごとの独立性</em>など、3 つ以上のシステムの独立性の他の概念がありますが、現時点では考慮しません。</p>
<p>標準基底ベクトルのテンソル積に関して先ほどみた事柄を一般化すると、任意の正の整数 <span class="math notranslate nohighlight">\(n\)</span> と任意の古典的な状態 <span class="math notranslate nohighlight">\(a_1,\ldots,a_n\)</span> に対して以下のようになります。</p>
<div class="math notranslate nohighlight">
\[
\vert a_1 \rangle \otimes \cdots \otimes \vert a_n \rangle
= \vert a_1 \cdots a_n \rangle
= \vert a_1,\ldots,a_n \rangle.
\]</div>
</section>
</section>
<section id="id11">
<h3>1.3 確率的状態の測定 <a id="multiple-systems-probabilistic-measurement"></a><a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>ここで、複数システムの確率的状態の測定に話を移しましょう。複数のシステムをまとめて一つのシステムとして見ることで、複数のシステムに対して測定がどのように機能しなければならないかという仕様がすぐに得られます–ただし、<em>すべての</em>システムが測定される場合に限ります。</p>
<p>例えば、2ビットの確率的な状態 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> が以下の確率ベクトルで記述されるとします。</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{2} \vert 00 \rangle + \frac{1}{2} \vert 11 \rangle,
\]</div>
<p>とすると、結果 <span class="math notranslate nohighlight">\(00\)</span> という結果、つまり <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定で <span class="math notranslate nohighlight">\(0\)</span>、<span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の測定で <span class="math notranslate nohighlight">\(0\)</span> 、が確率 <span class="math notranslate nohighlight">\(1/2\)</span> で得られ、 <span class="math notranslate nohighlight">\(11\)</span> という結果も確率 <span class="math notranslate nohighlight">\(1/2\)</span> で得られます。それぞれの場合に、我々の知識の確率ベクトルの記述を適宜更新し、確率的状態はそれぞれ <span class="math notranslate nohighlight">\(|00\rangle\)</span> または <span class="math notranslate nohighlight">\(|11\rangle\)</span>と なります。</p>
<section id="id12">
<h4>部分測定<a class="headerlink" href="#id12" title="Link to this heading">#</a></h4>
<p>しかし、<em>すべての</em>システムを測定するのではなく、システムの<em>適切な部分集合</em>だけを測定することにしたとします。この場合、測定された各システムの測定結果は、残りのシステムの知識にも（一般的に）影響を与えることになります。</p>
<p>ここでは、2つのシステムのうち、1つが測定されるケースに焦点を当てましょう。より一般的な状況-3つ以上のシステムの適切な部分集合が測定される場合-は、測定されるシステムをあたかも1つのシステムを形成しているかのようにまとめ、測定されないシステムをあたかも第2のシステムを形成しているかのようにみなすと、事実上2つのシステムのケースに縮約することができます。</p>
<p>正確には、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> は古典状態の集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> を持つシステム、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> は古典状態の集合 <span class="math notranslate nohighlight">\(\Gamma\)</span> を持つシステムで、この二つのシステムが一緒にある確率的状態にあると仮定します（いつものように）。ここでは、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を測定するだけで、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> には何もしない場合について考えます。 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> を測定して <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に何も起こらない状況は対称に扱われます。</p>
<p>まず、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> だけが測定されたときに特定の古典的状態 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> を観察する確率は、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> も測定されたという仮定の下で得られる確率と一致しなければならないことがわかっています。<br>つまり、</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}(\mathsf{X} = a)
  = \sum_{b\in\Gamma} \operatorname{Pr}\bigl( (\mathsf{X},\mathsf{Y})
  = (a,b) \bigr).
\]</div>
<p>これは、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> 単独のいわゆる<em>縮約</em>(または<em>周辺</em>) の 確率的状態の式です。</p>
<p>この式は直感的に理解できます：これが間違いであるためには、何か非常に奇妙なことが起こる必要があります。つまり、<span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定の確率は、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の結果に関係なく、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> も測定されたかどうかだけで影響される、ということを意味します。もし、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が遠い場所、例えば、別の銀河系にあるとしたら、光よりも速い信号伝達が可能になりますが、これは物理学の理解に基づいて否定されます。また、確率の解釈として、システムの状態に対する確信の度合いを表すという考え方もあります。  <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の測定は、既存の状態を明らかにするだけと考えるので、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を見る別の観測者が <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の測定を知らなくても、確率は変化しないはずです。</p>
<p><span class="math notranslate nohighlight">\(\mathsf{X}\)</span> だけが測定され、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> は測定されないと仮定すると、一般に <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の古典的状態に対する不確実性がまだ存在する可能性がります。このため、 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> と <span class="math notranslate nohighlight">\(b\in\Gamma\)</span> のある選択に対して、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の確率的状態を <span class="math notranslate nohighlight">\(\vert ab\rangle\)</span> に更新するのではなく、この <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に関するこの不確実性を適切に反映するように記述を更新する必要があります。</p>
<p>この不確実性を反映したのが、以下の<em>条件付き確率</em>の式です。</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}(\mathsf{Y} = b \,|\, \mathsf{X} = a)
  = \frac{
    \operatorname{Pr}\bigl((\mathsf{X},\mathsf{Y}) = (a,b)\bigr)
  }{
    \operatorname{Pr}(\mathsf{X} = a)
  }
\]</div>
<p>ここで、　<span class="math notranslate nohighlight">\(\operatorname{Pr}(\mathsf{Y} = b | \mathsf{X} = a)\)</span>　という式は、 <span class="math notranslate nohighlight">\(\mathsf{X} = a\)</span> の<em>条件</em>付き（または、が<em>与え</em>られた時の）<span class="math notranslate nohighlight">\(\mathsf{Y} = b\)</span> の確率を表します。</p>
<p>ただし、上の式は　<span class="math notranslate nohighlight">\(\operatorname{Pr}(\mathsf{X}=a)\)</span> が0でないときのみ定義されることに注意してください。もし、　<span class="math notranslate nohighlight">\(\operatorname{Pr}(\mathsf{X}=a) = 0\)</span>　であれば、不定形　<span class="math notranslate nohighlight">\(\frac{0}{0}\)</span>が得られます。しかし、 <span class="math notranslate nohighlight">\(\operatorname{Pr}(\mathsf{X}=a) = 0\)</span>であれば、 <span class="math notranslate nohighlight">\(a\)</span> を <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定結果としては観測しないので、この可能性を気にする必要はありません。</p>
<p>これらの式を確率ベクトルで表現するために、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の結合状態を記述する確率ベクトル  <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> を考えてみましょう。</p>
<div class="math notranslate nohighlight">
\[
  \vert\psi\rangle = \sum_{(a,b)\in\Sigma\times\Gamma} p_{ab} \vert ab\rangle
\]</div>
<p><span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を単独で測定すると、それぞれの可能な結果が確率で得られます。</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}(\mathsf{X} = a) = \sum_{b\in\Gamma} p_{ab}.
\]</div>
<p>したがって、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> のみの確率状態（すなわち、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の縮約された確率状態）を表すベクトルは、次式で与えられます。</p>
<div class="math notranslate nohighlight">
\[
  \sum_{a\in\Sigma} \biggl(\sum_{c\in\Gamma} p_{ac}\biggr) \vert a\rangle.
\]</div>
<p><span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定の結果 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> を得た後、条件付き確率の式に従って <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の確率的状態を更新し、以下の確率ベクトルで表現するようにします。</p>
<div class="math notranslate nohighlight">
\[
  \vert \pi_a \rangle
  = \frac{\sum_{b\in\Gamma}p_{ab}\vert b\rangle}{\sum_{c\in\Gamma} p_{ac}}.
\]</div>
<p>また、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定結果が古典状態 <span class="math notranslate nohighlight">\(a\)</span> であった場合、合成システムの確率的状態<span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の記述を <span class="math notranslate nohighlight">\(\vert a\rangle \otimes \vert\pi_a\rangle\)</span> のように更新します。</p>
<p>この <span class="math notranslate nohighlight">\(\vert\pi_a\rangle\)</span> の定義を考える方法の1つは、ベクトル <span class="math notranslate nohighlight">\(\sum_{b\in\Gamma} p_{ab} \vert b\rangle\)</span> の<em>正規化</em>と見なすことです。 このベクトルの要素の合計で割り、確率ベクトルを取得します。この正規化は、<span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定結果が <span class="math notranslate nohighlight">\(a\)</span> という結果になった場合の条件付けを効果的に説明します。</p>
<p>具体的な例として、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の古典的な状態集合が <span class="math notranslate nohighlight">\(\Sigma = \{0,1\}\)</span> 、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の古典的な状態集合が  <span class="math notranslate nohighlight">\(\Gamma = \{1,2,3\}\)</span> で、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の確率的状態が以下であるときを考えます。</p>
<div class="math notranslate nohighlight">
\[
  \vert \psi \rangle
  = \frac{1}{2}  \vert 0,1 \rangle
  + \frac{1}{12} \vert 0,3 \rangle
  + \frac{1}{12} \vert 1,1 \rangle
  + \frac{1}{6}  \vert 1,2 \rangle
  + \frac{1}{6}  \vert 1,3 \rangle.
\]</div>
<p>私たちの目標は、2 つの可能な結果 (<span class="math notranslate nohighlight">\(0\)</span> と <span class="math notranslate nohighlight">\(1\)</span>) の確率を決定し、システム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を測定したと仮定して、2つの結果に対する <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span>  の結果の確率的状態がどうであるかを計算することです。</p>
<p>テンソル積の双線形性、特に <em>2 番目</em>の引数が線形であるという事実を使用して、ベクトル <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> を次のように書き直すことができます。</p>
<div class="math notranslate nohighlight">
\[
  \vert \psi \rangle
  = \vert 0\rangle \otimes
  \biggl( \frac{1}{2} \vert 1 \rangle + \frac{1}{12} \vert 3 \rangle\biggr)
  + \vert 1\rangle \otimes
  \biggl( \frac{1}{12} \vert 1 \rangle + \frac{1}{6} \vert 2\rangle
  + \frac{1}{6} \vert 3 \rangle\biggr).
\]</div>
<p>測定されるシステムのための明確な標準基底ベクトルを分離し、2番目のシステムのためのすべての項を集めました。これは、どのようなベクトルから始めたかにかかわらず、常に可能であることが、少し考えればわかります。</p>
<p>このように整理しなおすと、測定結果の分析が容易になります。2つの結果の確率は次式で与えられます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{aligned}
    \operatorname{Pr}(\mathsf{X} = 0)
    &amp; = \frac{1}{2} + \frac{1}{12} = \frac{7}{12}\\[2mm]
    \operatorname{Pr}(\mathsf{X} = 1)
    &amp; = \frac{1}{12} + \frac{1}{6} + \frac{1}{6} = \frac{5}{12}.
  \end{aligned}
\end{split}\]</div>
<p>これらの確率の和は予想通り1になり、計算の確認に役立つことに注意してください。</p>
<p>また、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の確率的な状態は、括弧内のベクトルを正規化（先ほど計算した確率で割る）して確率ベクトルにすることですぐに推測することが可能です。すなわち、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が0であることを条件すると、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の確率的状態は以下のようになります。</p>
<div class="math notranslate nohighlight">
\[
 \frac{\frac{1}{2} \vert 1 \rangle + \frac{1}{12} \vert 3 \rangle}{\frac{7}{12}}
 = \frac{6}{7} \vert 1 \rangle + \frac{1}{7} \vert 3 \rangle,
\]</div>
<p><span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定値が 1 であると条件付けすると、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の確率的状態は次のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \frac{\frac{1}{12} \vert 1 \rangle + \frac{1}{6} \vert 2\rangle
  + \frac{1}{6} \vert 3 \rangle}{\frac{5}{12}}
  = \frac{1}{5} \vert 1 \rangle + \frac{2}{5} \vert 2 \rangle + \frac{2}{5} \vert 3 \rangle.
\]</div>
</section>
</section>
<section id="id13">
<h3>1.4 確率的状態の演算  <a id="multiple-systems-probabilistic-operations"></a><a class="headerlink" href="#id13" title="Link to this heading">#</a></h3>
<p>複数システムに対する古典的情報の考察の最後に、確率的状態にある複数システムに対する<em>演算</em>を考えてみましょう。 確率的状態と測定の時と同じ考え方で、複数のシステムをまとめて一つの合成システムと見なし、前の授業を参照してこれがどのように機能するかを確認できます。</p>
<p>典型的な2つのシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に戻って、合成システム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> に対する古典演算を考えてみましょう。前回の授業と上記の議論から、このような演算は行と列がデカルト積 <span class="math notranslate nohighlight">\(\Sigma\times\Gamma\)</span> でインデックスされる確率行列で表されると結論付けられます。</p>
<p>例えば、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> がビットであるとし、次のような記述を持つ演算を考えます。</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(\mathsf{X} = 1\)</span> の場合、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に対して NOT 演算を実行します。それ以外の場合は何もしません。</p>
</div></blockquote>
<p>これは、<em>制御NOT</em>演算と呼ばれる決定論的な演算です。ここで、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> は<em>制御</em>ビットで、<em>ターゲット</em>ビット <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> にNOT演算を適用するかどうかを決定します。この演算を行列表現すると次のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\[2mm]
0 &amp; 1 &amp; 0 &amp; 0\\[2mm]
0 &amp; 0 &amp; 0 &amp; 1\\[2mm]
0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}.
\end{split}\]</div>
<p>標準基底状態に対する作用は次の通りです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\vert 00 \rangle &amp; \mapsto \vert 00 \rangle\\
\vert 01 \rangle &amp; \mapsto \vert 01 \rangle\\
\vert 10 \rangle &amp; \mapsto \vert 11 \rangle\\
\vert 11 \rangle &amp; \mapsto \vert 10 \rangle
\end{aligned}
\end{split}\]</div>
<p>仮に <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span>の役割を交換し、  <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span>を制御ビット、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> をターゲットビットとすると、演算の行列表現は次のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\[2mm]
0 &amp; 0 &amp; 0 &amp; 1\\[2mm]
0 &amp; 0 &amp; 1 &amp; 0\\[2mm]
0 &amp; 1 &amp; 0 &amp; 0
\end{pmatrix}
\end{split}\]</div>
<p>標準基底状態での作用はこのようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\vert 00 \rangle &amp; \mapsto \vert 00 \rangle\\
\vert 01 \rangle &amp; \mapsto \vert 11 \rangle\\
\vert 10 \rangle &amp; \mapsto \vert 10 \rangle\\
\vert 11 \rangle &amp; \mapsto \vert 01 \rangle
\end{aligned}.
\end{split}\]</div>
<p>また、他の例として、このように演算を説明することもあります。</p>
<blockquote>
<div><p>確率 1/2 で、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> を <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と等しくなるように設定します。それ以外の場合は、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> と等しくなるように設定します。</p>
</div></blockquote>
<p>この操作の行列表現は次のとおりです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
1 &amp; \frac{1}{2} &amp; \frac{1}{2} &amp; 0\\[2mm]
0 &amp; 0 &amp; 0 &amp; 0\\[2mm]
0 &amp; 0 &amp; 0 &amp; 0\\[2mm]
0 &amp; \frac{1}{2} &amp; \frac{1}{2} &amp; 1
\end{pmatrix}
=
\frac{1}{2}
\begin{pmatrix}
1 &amp; 1 &amp; 0 &amp; 0\\[2mm]
0 &amp; 0 &amp; 0 &amp; 0\\[2mm]
0 &amp; 0 &amp; 0 &amp; 0\\[2mm]
0 &amp; 0 &amp; 1 &amp; 1
\end{pmatrix}
+
\frac{1}{2}
\begin{pmatrix}
1 &amp; 0 &amp; 1 &amp; 0\\[2mm]
0 &amp; 0 &amp; 0 &amp; 0\\[2mm]
0 &amp; 0 &amp; 0 &amp; 0\\[2mm]
0 &amp; 1 &amp; 0 &amp; 1
\end{pmatrix}.
\end{split}\]</div>
<p>標準基底ベクトルに対するこの操作の作用は次のとおりです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\vert 00 \rangle &amp; \mapsto \vert 00 \rangle\\[1mm]
\vert 01 \rangle &amp; \mapsto \frac{1}{2} \vert 00 \rangle + \frac{1}{2}\vert 11\rangle\\[1mm]
\vert 10 \rangle &amp; \mapsto \frac{1}{2} \vert 00 \rangle + \frac{1}{2}\vert 11\rangle\\[1mm]
\vert 11 \rangle &amp; \mapsto \vert 11 \rangle
\end{aligned}
\end{split}\]</div>
<p>これらの例では、2つのシステムをまとめて1つのシステムとして捉え、前回の授業と同様に進めているに過ぎません。</p>
<p>同じことが、いくつのシステムに対してもできます。例えば、3ビットの場合、3ビットをモジュロ <span class="math notranslate nohighlight">\(8\)</span> で増やし、つまり3ビットを2進数表記で <span class="math notranslate nohighlight">\(0\)</span> から <span class="math notranslate nohighlight">\(7\)</span> までの数をエンコードしていると考え、 <span class="math notranslate nohighlight">\(1\)</span> を加え、 <span class="math notranslate nohighlight">\(8\)</span> で割った余りを取る、と考えます。この演算は次のように書くことができます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
  &amp; \vert 001 \rangle \langle 000 \vert
    + \vert 010 \rangle \langle 001 \vert
    + \vert 011 \rangle \langle 010 \vert
    + \vert 100 \rangle \langle 011 \vert\\[1mm]
  &amp; \quad + \vert 101 \rangle \langle 100 \vert
    + \vert 110 \rangle \langle 101 \vert
    + \vert 111 \rangle \langle 110 \vert
    + \vert 000 \rangle \langle 111 \vert.
\end{aligned}
\end{split}\]</div>
<p>また、次のように書くこともできます。</p>
<div class="math notranslate nohighlight">
\[
\sum_{k = 0}^{7} \vert (k+1) \bmod 8 \rangle \langle k \vert,
\]</div>
<p>ケットの中の数字  <span class="math notranslate nohighlight">\(j\in\{0,1,\ldots,7\}\)</span> は、その数字の3ビット2進法符号化を指すということで合意したと仮定してください。第三の方法は、この演算を行列で表現することです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\
  1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}.
\end{split}\]</div>
<section id="id14">
<h4>独立した演算<a class="headerlink" href="#id14" title="Link to this heading">#</a></h4>
<p>ここで、複数のシステムがあり、それぞれのシステムに対して<em>独立</em>に<em>個別の演算</em>を行うとします。</p>
<p>例えば、古典状態集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> と <span class="math notranslate nohighlight">\(\Gamma\)</span> を持つ二つのシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> を用意し、<span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に対するある演算と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に対する別の演算を完全に独立に行うとします。前回の授業でわかったように、これらの演算は確率行列で表されます。正確には、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に対する操作を行列 <span class="math notranslate nohighlight">\(M\)</span> で表し、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に対する操作を行列 <span class="math notranslate nohighlight">\(N\)</span> で表すとしましょう。したがって、 <span class="math notranslate nohighlight">\(M\)</span> の行と列は <span class="math notranslate nohighlight">\(\Sigma\)</span> の要素に対応するインデックスを持ち、同様に <span class="math notranslate nohighlight">\(N\)</span> の行と列は <span class="math notranslate nohighlight">\(\Gamma\)</span> の要素に対応するインデックスを持ちます。</p>
<p>ここで、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> を合わせて一つの合成システム <span class="math notranslate nohighlight">\(( \mathsf{X},\mathsf{Y})\)</span> と考えたとき、この合成システムに対する二つの演算の合成作用を表す行列は何か、というのが自然な質問でしょう。この問いに答えるには、まず行列のテンソル積を導入する必要があります。これはベクトルのテンソル積と似ていて、同様に定義されています。</p>
</section>
<section id="id15">
<h4>行列のテンソル積<a class="headerlink" href="#id15" title="Link to this heading">#</a></h4>
<p>行列のテンソル積 <span class="math notranslate nohighlight">\(M\otimes N\)</span></p>
<div class="math notranslate nohighlight">
\[
  M = \sum_{a,b\in\Sigma} \alpha_{ab} \vert a\rangle \langle b\vert
\]</div>
<p>と</p>
<div class="math notranslate nohighlight">
\[
  N = \sum_{c,d\in\Gamma} \beta_{cd} \vert c\rangle \langle d\vert
\]</div>
<p>は、以下のような行列です。</p>
<div class="math notranslate nohighlight">
\[
  M \otimes N = \sum_{a,b\in\Sigma} \sum_{c,d\in\Gamma} \alpha_{ab} \beta_{cd} \vert ac \rangle \langle bd \vert
\]</div>
<p>同様に、 <span class="math notranslate nohighlight">\(a,b\in\Sigma\)</span> と <span class="math notranslate nohighlight">\(c,d\in\Gamma\)</span> のすべてにおいて、 <span class="math notranslate nohighlight">\(M\)</span> と <span class="math notranslate nohighlight">\(N\)</span> は次の式</p>
<div class="math notranslate nohighlight">
\[
\langle ac \vert M \otimes N \vert bd\rangle
= \langle a \vert M \vert b\rangle \langle c \vert N \vert d\rangle
\]</div>
<p>で定義されます。</p>
<p>別の方法で、 <span class="math notranslate nohighlight">\(M\otimes N\)</span> を説明する方法は、ベクトル <span class="math notranslate nohighlight">\(\vert\phi\rangle\)</span> および <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> のすべての可能な選択に対して、次の方程式を満たす唯一の行列であるということです。</p>
<div class="math notranslate nohighlight">
\[
  (M \otimes N)
  \bigl( \vert \phi \rangle \otimes \vert \psi \rangle \bigr)
  = \bigl(M \vert\phi\rangle\bigr) \otimes
  \bigl(N \vert\psi\rangle\bigr)
\]</div>
<p>(わかりやすくするために、ここでは <span class="math notranslate nohighlight">\(\vert\phi\rangle\)</span> の添字が <span class="math notranslate nohighlight">\(\Sigma\)</span> の要素に対応し、 <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> の添字が <span class="math notranslate nohighlight">\(\Gamma\)</span> に対応すると仮定します。)</p>
<p>前述したデカルト積の要素の並び方の慣習に従って、2つの行列のテンソル積を明示的に次のように書くこともできます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{gathered}
  \begin{pmatrix}
    \alpha_{11} &amp; \cdots &amp; \alpha_{1m} \\
    \vdots &amp; \ddots &amp; \vdots \\
    \alpha_{m1} &amp; \cdots &amp; \alpha_{mm}
  \end{pmatrix}
  \otimes
  \begin{pmatrix}
    \beta_{11} &amp; \cdots &amp; \beta_{1k} \\
    \vdots &amp; \ddots &amp; \vdots\\
    \beta_{k1} &amp; \cdots &amp; \beta_{kk}
  \end{pmatrix}
  \hspace{6cm}\\[2mm]
  \hspace{1cm}
 =
  \begin{pmatrix}
    \alpha_{11}\beta_{11} &amp; \cdots &amp; \alpha_{11}\beta_{1k} &amp; &amp; 
    \alpha_{1m}\beta_{11} &amp; \cdots &amp; \alpha_{1m}\beta_{1k} \\
    \vdots &amp; \ddots &amp; \vdots &amp; \hspace{2mm}\cdots\hspace{2mm} &amp; \vdots &amp; \ddots &amp; \vdots \\
    \alpha_{11}\beta_{k1} &amp; \cdots &amp; \alpha_{11}\beta_{kk} &amp; &amp; 
    \alpha_{1m}\beta_{k1} &amp; \cdots &amp; \alpha_{1m}\beta_{kk} \\[2mm]
    &amp; \vdots &amp; &amp; \ddots &amp; &amp; \vdots &amp; \\[2mm]
    \alpha_{m1}\beta_{11} &amp; \cdots &amp; \alpha_{m1}\beta_{1k} &amp; &amp; 
    \alpha_{mm}\beta_{11} &amp; \cdots &amp; \alpha_{mm}\beta_{1k} \\
    \vdots &amp; \ddots &amp; \vdots &amp; \hspace{2mm}\cdots\hspace{2mm} &amp; \vdots &amp; \ddots &amp; \vdots \\
    \alpha_{m1}\beta_{k1} &amp; \cdots &amp; \alpha_{m1}\beta_{kk} &amp; &amp; 
    \alpha_{mm}\beta_{k1} &amp; \cdots &amp; \alpha_{mm}\beta_{kk}
  \end{pmatrix}
\end{gathered}
\end{split}\]</div>
<p>3 つ以上の行列のテンソル積も同様の方法で定義されます。 <span class="math notranslate nohighlight">\(M_1, \ldots, M_n\)</span> が古典的な状態の集合 <span class="math notranslate nohighlight">\(\Sigma_1,\ldots,\Sigma_n\)</span> に対応する添字を持つ行列である場合、テンソル積 <span class="math notranslate nohighlight">\(M_1\otimes\cdots\otimes M_n\)</span> は、古典的な状態 <span class="math notranslate nohighlight">\(a_1,b_1\in\Sigma_1,\ldots,a_n,b_n\in\Sigma_n\)</span> のすべての選択に対して、次の条件によって</p>
<div class="math notranslate nohighlight">
\[
\langle a_1\cdots a_n \vert M_1\otimes\cdots\otimes M_n \vert b_1\cdots b_n\rangle
=
\langle a_1 \vert M_1 \vert b_1 \rangle \cdots\langle a_n \vert M_n \vert b_n \rangle
\]</div>
<p>定義されます。</p>
<p>また、3つ以上の行列のテンソル積をベクトルと同様に、2つの行列のテンソル積で再帰的に定義することもできます。</p>
<p>行列のテンソル積は、以下の式から、<em>乗法的</em>であると言われることがあります。</p>
<div class="math notranslate nohighlight">
\[
  (M_1\otimes\cdots\otimes M_n)(N_1\otimes\cdots\otimes N_n)
  = (M_1 N_1)\otimes\cdots\otimes (M_n N_n)
\]</div>
<p>これは、 <span class="math notranslate nohighlight">\(M_1,\ldots,M_n\)</span> と <span class="math notranslate nohighlight">\(N_1,\ldots,N_n\)</span> の任意の選択に対して、積 <span class="math notranslate nohighlight">\(M_1 N_1, \ldots, M_n N_n\)</span> が意味を成す場合、常に真です。</p>
</section>
<section id="id16">
<h4>独立した演算（続き）<a class="headerlink" href="#id16" title="Link to this heading">#</a></h4>
<p>以上の議論をまとめると、以下のことが分かります。 <span class="math notranslate nohighlight">\(M\)</span> を <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> 上の確率演算、 <span class="math notranslate nohighlight">\(N\)</span> を <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> 上の確率演算とし、この二つの演算を独立に行ったとき、合成システム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> に対する演算はテンソル積 <span class="math notranslate nohighlight">\(M\otimes N\)</span> となります。</p>
<p>ここでも確率的な状態でも見られるのは、<em>テンソル積は独立性を表す</em>ということです。二つのシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が独立に確率状態 <span class="math notranslate nohighlight">\(\vert\phi\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert\pi\rangle\)</span> にあるとすると、合成システム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> は確率状態 <span class="math notranslate nohighlight">\(\vert\phi\rangle\otimes\vert\pi\rangle\)</span> にあることがわかります。そして、この2つのシステムに確率的操作 <span class="math notranslate nohighlight">\(M\)</span> と <span class="math notranslate nohighlight">\(N\)</span> を独立に適用すると、結果として合成システム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> に対する作用は、演算 <span class="math notranslate nohighlight">\(M\otimes N\)</span> で記述されることになります。</p>
<p>前回のビット1個に対する確率演算を思い出して、例題を見てみましょう。ビットの古典的状態が <span class="math notranslate nohighlight">\(0\)</span> ならそのまま、 <span class="math notranslate nohighlight">\(1\)</span> なら確率 <span class="math notranslate nohighlight">\(1/2\)</span> で0に反転させる演算は、以下の行列で表されます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
    1 &amp; \frac{1}{2}\\[1mm]
    0 &amp; \frac{1}{2}
  \end{pmatrix},
\end{split}\]</div>
<p>この演算をビット <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に対して行い、2番目のビット <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に対して（独立に）NOT演算を行った場合、合成システム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> に対する合成演算は行列表現となります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
    1 &amp; \frac{1}{2}\\[1mm]
    0 &amp; \frac{1}{2}
  \end{pmatrix}
  \otimes
  \begin{pmatrix}
    0 &amp; 1\\[1mm]
    1 &amp; 0
  \end{pmatrix}
  =
  \begin{pmatrix}
    0 &amp; 1 &amp; 0 &amp; \frac{1}{2} \\[1mm]
    1 &amp; 0 &amp; \frac{1}{2} &amp; 0 \\[1mm]
    0 &amp; 0 &amp; 0 &amp; \frac{1}{2} \\[1mm]
    0 &amp; 0 &amp; \frac{1}{2} &amp; 0
  \end{pmatrix}.
\end{split}\]</div>
<p>調べると、これは確率行列であることがわかります。</p>
<p>これは常に当てはまります：2 つ以上の確率行列のテンソル積は常に確率的です。</p>
<p>あるシステムに対してある演算を行い、別のシステムに対しては<em>何もしない</em>という状況はよくあることです。このような場合、<em>何もしない</em>は単位行列で表されることに注意して、全く同じ処方箋に従います。例えば、ビット <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を <span class="math notranslate nohighlight">\(0\)</span> にリセットし、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に何もしない場合、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> 行列で表される確率的（実際には決定論的）な次の演算が返されます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
    1 &amp; 1\\[1mm]
    0 &amp; 0
  \end{pmatrix}
  \otimes
  \begin{pmatrix}
    1 &amp; 0\\[1mm]
    0 &amp; 1
  \end{pmatrix}
  =
  \begin{pmatrix}
    1 &amp; 0 &amp; 1 &amp; 0 \\[1mm]
    0 &amp; 1 &amp; 0 &amp; 1 \\[1mm]
    0 &amp; 0 &amp; 0 &amp; 0 \\[1mm]
    0 &amp; 0 &amp; 0 &amp; 0
  \end{pmatrix}.
\end{split}\]</div>
</section>
</section>
</section>
<section id="id17">
<h2>2. 量子情報 <a id="multiple-systems-quantum-info"></a><a class="headerlink" href="#id17" title="Link to this heading">#</a></h2>
<p>さて、次は複数システムの量子情報です。前回の単一システムの場合と同様に、複数システムの量子情報の数学的記述も、確率的な場合とよく似ており、同様の概念と技法が用いられています。</p>
<section id="id18">
<h3>2.1 量子状態<a id="multiple-systems-quantum-states"></a><a class="headerlink" href="#id18" title="Link to this heading">#</a></h3>
<p>複数のシステムをまとめて一つの合成システムとして見ることができます。このことは、確率論的な設定においてすでに観察されており、量子論的な設定も同様です。</p>
<p>つまり、複数システムの量子状態は、単一システムの量子状態と同様に、複素数の要素を持ち、ユークリッドノルムが1に等しい列ベクトルで表現されます。複数システムの場合、これらのベクトルの添字は、個々のシステムの古典状態の集合の<em>デカルト積</em>に対応するように配置されます（合成システムの古典状態の集合であるため）。</p>
<p>例えば、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が量子ビットの場合、量子ビットのペア <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> を一つのシステムとしてまとめてみたときの古典状態の集合はデカルト積 <span class="math notranslate nohighlight">\(\{0,1\}\times\{0,1\}\)</span> となるわけです。2値の組を長さ2の2進文字列で表すことにより、このデカルト積の集合を集合 <span class="math notranslate nohighlight">\(\{00,01,10,11\}\)</span> と関連付けることができます。<br>したがって、以下のベクトルはすべて <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の組の量子状態ベクトルの例となります。</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{\sqrt{2}} \vert 00 \rangle
  - \frac{1}{\sqrt{6}} \vert 01\rangle
  + \frac{i}{\sqrt{6}} \vert 10\rangle
  + \frac{1}{\sqrt{6}} \vert 11\rangle, \qquad
  \frac{3}{5} \vert 00\rangle - \frac{4}{5} \vert 11\rangle,
  \qquad \text{and} \qquad
  \vert 01 \rangle.
\]</div>
<p>複数システムの量子状態ベクトルの表現方法にはバリエーションがあり、好みに応じて選択することができます。以下は、上記の1つ目の量子状態ベクトルに対する例です。</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\vert ab\rangle = \vert a\rangle \vert b\rangle\)</span>  (任意の古典的な状態 <span class="math notranslate nohighlight">\(a\)</span> および <span class="math notranslate nohighlight">\(b\)</span> ) という事実を使用して、代わりに次のように記述できます。</p></li>
</ol>
<div class="math notranslate nohighlight">
\[
  \frac{1}{\sqrt{2}} \vert 0\rangle\vert 0 \rangle
  - \frac{1}{\sqrt{6}} \vert 0\rangle\vert 1\rangle
  + \frac{i}{\sqrt{6}} \vert 1\rangle\vert 0\rangle
  + \frac{1}{\sqrt{6}} \vert 1\rangle\vert 1\rangle.
\]</div>
<ol class="arabic simple">
<li><p>テンソル積の記号を明示的に次のように書くこともできます。</p></li>
</ol>
<div class="math notranslate nohighlight">
\[
  \frac{1}{\sqrt{2}} \vert 0\rangle\otimes\vert 0 \rangle
  - \frac{1}{\sqrt{6}} \vert 0\rangle\otimes\vert 1\rangle
  + \frac{i}{\sqrt{6}} \vert 1\rangle\otimes\vert 0\rangle
  + \frac{1}{\sqrt{6}} \vert 1\rangle\otimes\vert 1\rangle.
\]</div>
<ol class="arabic simple">
<li><p>次のように、考えているシステムにどのように対応するかを示すために、ケットに添え字をつけることができます。</p></li>
</ol>
<div class="math notranslate nohighlight">
\[
  \frac{1}{\sqrt{2}} \vert 0\rangle_{\mathsf{X}}\vert 0 \rangle_{\mathsf{Y}}
  - \frac{1}{\sqrt{6}} \vert 0\rangle_{\mathsf{X}}\vert 1\rangle_{\mathsf{Y}}
  + \frac{i}{\sqrt{6}} \vert 1\rangle_{\mathsf{X}}\vert 0\rangle_{\mathsf{Y}}
  + \frac{1}{\sqrt{6}} \vert 1\rangle_{\mathsf{X}}\vert 1\rangle_{\mathsf{Y}}.
\]</div>
<p>もちろん、量子状態ベクトルを列ベクトルとして明示的に記述することもできます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
  \frac{1}{\sqrt{2}}\\
  - \frac{1}{\sqrt{6}}\\
  \frac{i}{\sqrt{6}}\\
  \frac{1}{\sqrt{6}}
  \end{pmatrix}.
\end{split}\]</div>
<p>出現する文脈に応じて、これらのバリエーションのいずれかが優先される場合がありますが、同じベクトルを記述するという意味で、それらはすべて同等です。</p>
<section id="id19">
<h4>量子状態ベクトルのテンソル積<a class="headerlink" href="#id19" title="Link to this heading">#</a></h4>
<p>確率ベクトルの場合と同様に、量子状態ベクトルのテンソル積も量子状態ベクトルであり、システム間の<em>独立性</em>を表します。</p>
<p>具体的には、2 つのシステムの場合から始めて、 <span class="math notranslate nohighlight">\(\vert \phi \rangle\)</span> がシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の量子状態ベクトルであり、<span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> がシステム <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の量子状態ベクトルであるとします。テンソル積 <span class="math notranslate nohighlight">\(\vert \phi \rangle \otimes \vert \psi \rangle\)</span> は、 <span class="math notranslate nohighlight">\(\vert \phi \rangle \vert \psi \rangle\)</span> または、 <span class="math notranslate nohighlight">\(\vert \phi \otimes \psi \rangle\)</span> と書くこともでき、合成システム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の量子状態ベクトルです。<br>このような状態を<em>積状態</em>と呼びます。</p>
<p>直感的に言えば、2つのシステム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> が積状態 <span class="math notranslate nohighlight">\(\vert \phi \rangle \otimes \vert \psi \rangle\)</span> にあるとき、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> は量子状態 <span class="math notranslate nohighlight">\(\vert \phi \rangle\)</span>にあり、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> は量子状態 <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> にある、と解釈でき、2つのシステムの状態は互いに何の関係もありません。</p>
<p>テンソル積ベクトル <span class="math notranslate nohighlight">\(\vert \phi \rangle \otimes \vert \psi \rangle\)</span> が実際に量子状態ベクトルであるという事実は、テンソル積に関して<em>乗法</em>であるユークリッドノルムと一致しています。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
  \bigl\| \vert \phi \rangle \otimes \vert \psi \rangle \bigr\| 
  &amp; = \sqrt{ 
    \sum_{(a,b)\in\Sigma\times\Gamma} 
    \bigl\vert\langle ab \vert \phi\otimes\psi \rangle \bigr\vert^2
  }\\[1mm]
  &amp; = \sqrt{ 
    \sum_{a\in\Sigma} \sum_{b\in\Gamma}
    \bigl\vert\langle a \vert \phi \rangle 
    \langle b \vert \psi \rangle \bigr\vert^2
  }\\[1mm]
  &amp; = \sqrt{ 
    \biggl(\sum_{a\in\Sigma} 
    \bigl\vert \langle a \vert \phi \rangle \bigr\vert^2
    \biggr)
    \biggl(\sum_{b\in\Gamma} 
    \bigl\vert \langle b \vert \psi \rangle \bigr\vert^2
    \biggr)
  }\\[1mm]
  &amp; = \bigl\| 
    \vert \phi \rangle \bigr\| \bigl\| \vert \psi \rangle 
  \bigr\|.
\end{aligned}
\end{split}\]</div>
<p>したがって、 <span class="math notranslate nohighlight">\(\vert \phi \rangle\)</span> と <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> は量子状態ベクトルであるため、 <span class="math notranslate nohighlight">\(\|\vert \phi \rangle\| = 1\)</span> と <span class="math notranslate nohighlight">\(\|\vert \psi \rangle\| = 1\)</span> が得られます。 したがって <span class="math notranslate nohighlight">\(\|\vert \phi \rangle \otimes \vert \psi \rangle\| = 1\)</span> なので、 <span class="math notranslate nohighlight">\(\vert \phi \rangle \otimes \vert \psi \rangle\)</span> も量子状態ベクトルです。</p>
<p>この議論は、2 つ以上のシステムに一般化することができます。 <span class="math notranslate nohighlight">\(\vert \psi_1 \rangle,\ldots,\vert \psi_n \rangle\)</span> がシステム <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> の量子状態ベクトルの場合、 <span class="math notranslate nohighlight">\(\vert \psi_1 \rangle\otimes\cdots\otimes \vert \psi_n \rangle\)</span> は、合成システム <span class="math notranslate nohighlight">\((\mathsf{X}_1,\ldots,\mathsf{X}_n)\)</span> の<em>積状態</em>を表す量子状態ベクトルです。繰り返しますが、ここでも、これが量子状態ベクトルであることがわかるのは、次のような理由からです。</p>
<div class="math notranslate nohighlight">
\[
  \bigl\|
  \vert \psi_1 \rangle\otimes\cdots\otimes \vert \psi_n \rangle
  \bigr\|
  = \bigl\|\vert \psi_1 \rangle\bigl\| \cdots
  \bigl\|\vert \psi_n \rangle \bigr\| = 1^n = 1.
\]</div>
</section>
<section id="id20">
<h4>エンタングル状態<a class="headerlink" href="#id20" title="Link to this heading">#</a></h4>
<p>複数のシステムのすべての量子状態ベクトルが積状態であるとは限りません。たとえば、2量子ビットの量子状態ベクトル</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{\sqrt{2}} \vert 00\rangle + \frac{1}{\sqrt{2}} \vert 11\rangle
  \tag{7}
\]</div>
<p>は積状態ではありません。これを推論するために、ベクトル  <span class="math notranslate nohighlight">\((5)\)</span> によって表される確率的状態が積状態ではないことを証明するために使用したのとまったく同じ議論に従うことができます。</p>
<p>つまり、 <span class="math notranslate nohighlight">\((7)\)</span> が積状態である場合、次のような量子状態ベクトル <span class="math notranslate nohighlight">\(\vert\phi\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> が存在します。</p>
<div class="math notranslate nohighlight">
\[
  \vert\phi\rangle\otimes\vert\psi\rangle
  = \frac{1}{\sqrt{2}} \vert 00\rangle
  + \frac{1}{\sqrt{2}} \vert 11\rangle.
\]</div>
<p>しかし、その場合、必然的に次のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \langle 0 \vert \phi\rangle
  \langle 1 \vert \psi\rangle
  = \langle 01 \vert \phi\otimes\psi\rangle
  = 0
\]</div>
<p>これは、 <span class="math notranslate nohighlight">\(\langle 0 \vert \phi\rangle = 0\)</span> または <span class="math notranslate nohighlight">\(\langle 1 \vert \psi\rangle = 0\)</span> (または両方) であることを意味します。それは、次の事実に反します。</p>
<div class="math notranslate nohighlight">
\[
  \langle 0 \vert \phi\rangle \langle 0 \vert \psi\rangle
  = \langle 00 \vert \phi\otimes\psi\rangle
  = \frac{1}{\sqrt{2}}
\]</div>
<p>と</p>
<div class="math notranslate nohighlight">
\[
  \langle 1 \vert \phi\rangle \langle 1 \vert \psi\rangle
  = \langle 11 \vert \phi\otimes\psi\rangle
  = \frac{1}{\sqrt{2}}
\]</div>
<p>が両方とも非ゼロであることです。</p>
<p>特定の値 <span class="math notranslate nohighlight">\(1/\sqrt{2}\)</span> は、この引数にとって重要ではないことに注意してください。重要なのは、この値がゼロでないことです。したがって、たとえば、量子状態</p>
<div class="math notranslate nohighlight">
\[
  \frac{3}{5} \vert 00\rangle + \frac{4}{5} \vert 11\rangle
\]</div>
<p>も同様の理由で積状態ではありません。</p>
<p>したがって、量子状態ベクトル <span class="math notranslate nohighlight">\((7)\)</span> は 2 つのシステム間の<em>相関</em>を表し、具体的にはシステムが<em>エンタングル</em>していると言います。</p>
<p>エンタングルメントは量子情報の典型的な特徴であり、後の授業でさらに詳しく説明します。エンタングルメントは、特に、授業 1 で述べた量子情報の一般的な密度行列の定式化で記述できる種類のノイズの多い量子状態の場合、複雑になります。しかし、この章で取り上げる単純化された定式化の量子状態ベクトルでは、エンタングルメントは相関と等価となります。つまり、積ベクトルでない量子状態ベクトルは、すべてエンタングルした状態を表しているのです。</p>
<p>対照的に、量子状態ベクトル</p>
<div class="math notranslate nohighlight">
\[
   \frac{1}{2} \vert 00\rangle
 + \frac{i}{2} \vert 01\rangle
 - \frac{1}{2} \vert 10\rangle
 - \frac{i}{2} \vert 11\rangle
\]</div>
<p>は、積状態の一例です：</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{2} \vert 00\rangle
  + \frac{i}{2} \vert 01\rangle
  - \frac{1}{2} \vert 10\rangle
  - \frac{i}{2} \vert 11\rangle
  =
  \biggl(
    \frac{1}{\sqrt{2}}\vert 0\rangle - \frac{1}{\sqrt{2}}\vert 1\rangle
  \biggr)
  \otimes
  \biggl(
    \frac{1}{\sqrt{2}}\vert 0\rangle + \frac{i}{\sqrt{2}}\vert 1\rangle
  \biggr).
\]</div>
<p>したがって、この状態はエンタングルではありません。</p>
</section>
<section id="id21">
<h4>ベル状態<a class="headerlink" href="#id21" title="Link to this heading">#</a></h4>
<p><em>ベル状態</em>から始めて、複数量子ビットの量子状態の重要な例をいくつか見ていきます。ベル状態は、次の 4 つの 2 量子ビット状態です。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
  \vert \phi^+ \rangle &amp; = \frac{1}{\sqrt{2}} \vert 00 \rangle 
                         + \frac{1}{\sqrt{2}} \vert 11 \rangle \\[1mm]
  \vert \phi^- \rangle &amp; = \frac{1}{\sqrt{2}} \vert 00 \rangle 
                         - \frac{1}{\sqrt{2}} \vert 11 \rangle \\[1mm]
  \vert \psi^+ \rangle &amp; = \frac{1}{\sqrt{2}} \vert 01 \rangle 
                         + \frac{1}{\sqrt{2}} \vert 10 \rangle \\[1mm]
  \vert \psi^- \rangle &amp; = \frac{1}{\sqrt{2}} \vert 01 \rangle 
                         - \frac{1}{\sqrt{2}} \vert 10 \rangle
\end{aligned}
\end{split}\]</div>
<p>ベル状態は、<a class="reference internal" href="#gloss:john-bell"><span class="xref myst">ジョン・ベル</span></a>にちなんで名付けられました。</p>
<p><span class="math notranslate nohighlight">\(\vert\phi^+\rangle\)</span> が積状態でないことを証明する同じ議論によって、他のベル状態も積状態でないことが明らかになることに注意してください。 — ベル状態の 4 つすべてが 2 つの量子ビット間のエンタングルメントを表しています。</p>
<p>4 つのベルの状態のすべての集まり</p>
<div class="math notranslate nohighlight">
\[
  \bigl\{\vert \phi^+ \rangle, \vert \phi^- \rangle, \vert \psi^+ \rangle, \vert \psi^- \rangle\bigr\}
\]</div>
<p>は、 <em>ベル基底</em>として知られています。 2量子ビットの任意の量子状態ベクトル、または実際には 2 ビットの 4 つの古典的な状態に対応する要素を持つ任意の複素ベクトルは、4 つのベル状態の線形結合として表現できます。例えば、次のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \vert 0 0 \rangle
  = \frac{1}{\sqrt{2}} \vert \phi^+\rangle
  + \frac{1}{\sqrt{2}} \vert \phi^-\rangle.
\]</div>
</section>
<section id="ghz-w">
<h4>GHZ と W 状態<a class="headerlink" href="#ghz-w" title="Link to this heading">#</a></h4>
<p>次に、3 量子ビット状態の 2 つの興味深い例を検討します。</p>
<p>最初の例は、3 量子ビット <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y},\mathsf{Z})\)</span> の量子を表す <em>GHZ 状態</em>です。(最初にその性質を研究した Daniel Greenberger, Michael Horne, Anton Zeilinger に敬意を表してこの名が付きました):</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{\sqrt{2}} \vert 000\rangle +
  \frac{1}{\sqrt{2}} \vert 111\rangle.
\]</div>
<p>2 番目の例は、いわゆる W 状態です。</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{\sqrt{3}} \vert 001\rangle +
  \frac{1}{\sqrt{3}} \vert 010\rangle +
  \frac{1}{\sqrt{3}} \vert 100\rangle.
\]</div>
<p>これらの状態はどちらも積状態ではありません。つまり、3 量子ビットの量子状態ベクトルのテンソル積として記述することはできません。</p>
<p>この2つの状態については、複数システムの量子状態の部分測定の際に、さらに検討します。</p>
</section>
<section id="id22">
<h4>追加の例<a class="headerlink" href="#id22" title="Link to this heading">#</a></h4>
<p>これまで見てきた複数システムの量子状態の例は、2 つか 3 つの量子ビットの状態ですが、異なる古典状態の集合を持つ複数システムの量子状態を持つこともできます。</p>
<p>たとえば、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span>,  <span class="math notranslate nohighlight">\(\mathsf{Z}\)</span> の 3 つのシステムの量子状態の例です。ここで、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の古典状態の集合はバイナリーアルファベット (つまり <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> は量子ビット) であり、<span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Z}\)</span> の古典状態の集合は <span class="math notranslate nohighlight">\(\{\clubsuit,\diamondsuit,\heartsuit,\spadesuit\}\)</span> です:</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{2} \vert 0 \rangle \vert \heartsuit\rangle
  \vert \heartsuit \rangle
  +
  \frac{1}{2} \vert 1 \rangle \vert \spadesuit\rangle
  \vert \heartsuit \rangle
  -
  \frac{1}{\sqrt{2}} \vert 0 \rangle \vert \heartsuit\rangle
  \vert \diamondsuit \rangle.
\]</div>
<p>こちらも、 3 つのシステム <span class="math notranslate nohighlight">\((\mathsf{X}, \mathsf{Y}, \mathsf{Z})\)</span> の量子状態の例です。ここで、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{Y} \)</span> 、および  <span class="math notranslate nohighlight">\(\mathsf{Z}\)</span> はすべて、同じ古典状態の集合 <span class="math notranslate nohighlight">\(\{0,1,2\}\)</span> を共有します。</p>
<div class="math notranslate nohighlight">
\[
  \frac{
    \vert 012 \rangle
    - \vert 021 \rangle
    + \vert 120 \rangle
    - \vert 102 \rangle
    + \vert 201 \rangle
    - \vert 210 \rangle
  }{\sqrt{6}}.
\]</div>
<p>古典状態の集合 <span class="math notranslate nohighlight">\(\{0,1,2\}\)</span> を持つシステムは、多くの場合、<em>トリット</em>と呼ばれます。または、それらが量子状態にある可能性を考慮して、<em>キュートリット</em>と呼ばれます。 <em>qudit</em>という用語は、 <span class="math notranslate nohighlight">\(d\)</span> 個の任意の選択に対して、古典的な状態の集合  <span class="math notranslate nohighlight">\(\{0,\ldots,d-1\}\)</span> を持つシステムを指します。</p>
</section>
</section>
<section id="id23">
<h3>2.2 量子状態の測定 <a id="multiple-systems-quantum-measurements"></a><a class="headerlink" href="#id23" title="Link to this heading">#</a></h3>
<p>単一システムの量子状態の標準基底測定については、前回の授業で説明しました。古典状態の集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> を持つシステムがベクトル <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> で表される量子状態にあり、そのシステムを（標準基底測定に関して）測定すると、各古典状態 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> が確率 <span class="math notranslate nohighlight">\(\vert \langle a \vert \psi \rangle\vert^2\)</span> で出現します。</p>
<p>これは、複数のシステムの量子状態があり、合成システム全体を測定する（これはシステムの<em>すべて</em>を測定することと等しい）ことを選択したときに何が起こるかを教えてくれます。具体的に言うと、 <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> がそれぞれ古典状態の集合 <span class="math notranslate nohighlight">\(\Sigma_1,\ldots,\Sigma_n\)</span> を持つシステムだとします。このとき、 <span class="math notranslate nohighlight">\((\mathsf{X}_1,\ldots,\mathsf{X}_n)\)</span> をまとめて、古典状態集合がデカルト積 <span class="math notranslate nohighlight">\(\Sigma_1\times\cdots\times\Sigma_n\)</span> である一つのシステムとみなしてよいでしょう。このシステムの量子状態を量子状態ベクトル <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> で表し、すべてのシステムを測定すると、各可能な結果 <span class="math notranslate nohighlight">\((a_1,\ldots,a_n)\in\Sigma_1\times\cdots\times\Sigma_n\)</span> は確率 <span class="math notranslate nohighlight">\(\vert\langle a_1\cdots a_n\vert \psi\rangle\vert^2\)</span> で現れることになります。</p>
<p>例えば、システム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が合成して以下の量子状態にあるとき</p>
<div class="math notranslate nohighlight">
\[
\frac{3}{5} \vert 0\rangle \vert \heartsuit \rangle
- \frac{4i}{5} \vert 1\rangle \vert \spadesuit \rangle,
\]</div>
<p>両システムを標準基底で測定すると、確率 <span class="math notranslate nohighlight">\(9/25\)</span> で <span class="math notranslate nohighlight">\((0,\heartsuit)\)</span> の結果が得られ、確率 <span class="math notranslate nohighlight">\(16/25\)</span> で <span class="math notranslate nohighlight">\((1,\spadesuit)\)</span> の結果が得られます。</p>
<section id="id24">
<h4>2 つのシステムの部分測定<a class="headerlink" href="#id24" title="Link to this heading">#</a></h4>
<p>ここで、ある量子状態の複数のシステムがあり、その部分集合を測定する場合を考えてみましょう。先程と同じく、古典状態の集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> と <span class="math notranslate nohighlight">\(\Gamma\)</span> を持つ2つのシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> から始めます。</p>
<p>一般に、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の量子状態ベクトルは次のような形をとります。</p>
<div class="math notranslate nohighlight">
\[
  \vert \psi \rangle
  = \sum_{(a,b)\in\Sigma\times\Gamma} \alpha_{ab} \vert ab\rangle,
\]</div>
<p>ここで、  <span class="math notranslate nohighlight">\(\{\alpha_{ab} : (a,b)\in\Sigma\times\Gamma\}\)</span> は、次を満たす複素数の集合です。</p>
<div class="math notranslate nohighlight">
\[
  \sum_{(a,b)\in\Sigma\times\Gamma} \vert \alpha_{ab} \vert^2 = 1
\]</div>
<p>(これは <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> が単位ベクトルであることと同等です)。</p>
<p>もし、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の両方が測定されたなら、それぞれの可能な結果 <span class="math notranslate nohighlight">\((a,b)\in\Sigma\times\Gamma\)</span> は次の確率で現れることが、上の議論から既に分かっています。</p>
<div class="math notranslate nohighlight">
\[
  \bigl\vert \langle ab \vert \psi \rangle \bigr\vert^2 = \vert\alpha_{ab}\vert^2.
\]</div>
<p>したがって、最初のシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> だけが測定されると仮定すると、各結果 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> が現れる確率は次のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \sum_{b\in\Gamma}
  \bigl\vert \langle ab \vert \psi \rangle \bigr\vert^2
  =
  \sum_{b\in\Gamma}
  \vert\alpha_{ab}\vert^2.
\]</div>
<p>これは確率的な設定で既に見たことと一致し、また物理の理解とも一致します。つまり、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を測定したときに特定の結果が現れる確率は、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> も測定したかどうかに依存することはありえません。そうでなければ、超光速通信が可能になるからです。</p>
<p>この <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定で特定の結果 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> を得たとき、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の量子状態は単一システムのときと同じように <span class="math notranslate nohighlight">\(\vert a\rangle\)</span>に等しくなるように変化すると予想されます。<br>しかし、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span>の量子状態はどうなるのでしょうか？</p>
<p>この問いに答えるために、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を（標準基底で）測定し、その結果を古典状態 <span class="math notranslate nohighlight">\(a\)</span> と仮定して、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の合成量子状態を記述してみましょう。</p>
<p>まず、ベクトル <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> を次のように表します。</p>
<div class="math notranslate nohighlight">
\[
  \vert\psi\rangle
  = \sum_{a\in\Sigma}
  \vert a \rangle
  \otimes \vert \phi_a \rangle,
\]</div>
<p>このとき <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> ごとに以下です。</p>
<div class="math notranslate nohighlight">
\[
  \vert \phi_a \rangle = \sum_{b\in\Gamma} \alpha_{ab} \vert b\rangle
\]</div>
<p><span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の標準基底測定がそれぞれ結果 <span class="math notranslate nohighlight">\(a\)</span> になる確率は、次のように記述できることに注意してください。</p>
<div class="math notranslate nohighlight">
\[
  \sum_{b\in\Gamma} \vert\alpha_{ab}\vert^2 = \bigl\| \vert \phi_a \rangle \bigr\|^2.
\]</div>
<p>ここで、<span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の標準基底測定の結果 <span class="math notranslate nohighlight">\(a\)</span> が得られた結果、ペア <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の量子状態が得られます。</p>
<div class="math notranslate nohighlight">
\[
  \vert a \rangle \otimes \frac{\vert \phi_a \rangle}{\|\vert \phi_a \rangle\|}.
\]</div>
<p>つまり、単一システムの場合のように状態は「崩壊」しますが、それは、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定が結果 <span class="math notranslate nohighlight">\(a\)</span> を生成したことと状態が一致するために必要な範囲だけです。</p>
<p>非公式に言うと、<span class="math notranslate nohighlight">\(\vert a \rangle \otimes \vert \phi_a\rangle\)</span> は、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の測定が結果 <span class="math notranslate nohighlight">\(a\)</span> をもたらしたことと一致する <span class="math notranslate nohighlight">\(\vert \psi\rangle\)</span> の成分を表しています。このベクトルをユークリッドノルムで割って正規化すると、ユークリッドノルムが <span class="math notranslate nohighlight">\(1\)</span> になる量子状態ベクトルが得られます。この正規化ステップは、確率論的な設定でベクトルを要素の合計で割って確率ベクトルを得たときに行ったことと類似しています。</p>
<p>この章の最初の例で 2 つの量子ビット <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の状態を考えてみましょう。</p>
<div class="math notranslate nohighlight">
\[
  \vert \psi \rangle
  = \frac{1}{\sqrt{2}} \vert 00 \rangle
  - \frac{1}{\sqrt{6}} \vert 01 \rangle
  + \frac{i}{\sqrt{6}} \vert 10 \rangle
  + \frac{1}{\sqrt{6}} \vert 11 \rangle.
\]</div>
<p>最初のシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が測定されたときに何が起こるかを理解するために、次のように書きます。</p>
<div class="math notranslate nohighlight">
\[
  \vert \psi \rangle
  = \vert 0 \rangle \otimes \biggl(
    \frac{1}{\sqrt{2}}  \vert 0 \rangle
    - \frac{1}{\sqrt{6}} \vert 1 \rangle \biggr)
    + \vert 1 \rangle \otimes \biggl(
    \frac{i}{\sqrt{6}} \vert 0 \rangle
    + \frac{1}{\sqrt{6}} \vert 1 \rangle \biggr).
\]</div>
<p>上記の説明に基づいて、結果 <span class="math notranslate nohighlight">\(0\)</span> が測定される確率は次のようになることがわかります。</p>
<div class="math notranslate nohighlight">
\[
  \biggl\|\frac{1}{\sqrt{2}}  \vert 0 \rangle
  -\frac{1}{\sqrt{6}} \vert 1 \rangle\biggr\|^2
  = \frac{1}{2} + \frac{1}{6}
  = \frac{2}{3}
\]</div>
<p>この場合、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の状態は次のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \vert 0\rangle \otimes
  \frac{\frac{1}{\sqrt{2}} \vert 0 \rangle
  -\frac{1}{\sqrt{6}} \vert 1 \rangle}{\sqrt{\frac{2}{3}}}
  = \vert 0\rangle \otimes
  \Biggl( \sqrt{\frac{3}{4}} \vert 0 \rangle
  -\frac{1}{2} \vert 1\rangle\Biggr);
\]</div>
<p>測定結果が <span class="math notranslate nohighlight">\(1\)</span> になる確率は</p>
<div class="math notranslate nohighlight">
\[
  \biggl\|\frac{i}{\sqrt{6}}  \vert 0 \rangle
  + \frac{1}{\sqrt{6}} \vert 1 \rangle\biggr\|^2
  = \frac{1}{6} + \frac{1}{6}
  = \frac{1}{3},
\]</div>
<p>この場合、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の状態は次のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \vert 1\rangle \otimes
  \frac{\frac{i}{\sqrt{6}} \vert 0 \rangle
  +\frac{1}{\sqrt{6}} \vert 1 \rangle}{\sqrt{\frac{1}{3}}}
  = \vert 1\rangle \otimes
  \Biggl( \frac{i}{\sqrt{2}} \vert 0 \rangle
  +\frac{1}{\sqrt{2}} \vert 1\rangle\Biggr).
\]</div>
<p>同じ手法を対称的に用いて、1番目のシステムではなく 2 番目のシステム <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が測定された場合に何が起こるかを説明します。ベクトル <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> を次のように書き換えます。</p>
<div class="math notranslate nohighlight">
\[
  \vert \psi \rangle
  = \biggl(
    \frac{1}{\sqrt{2}} \vert 0 \rangle
    + \frac{i}{\sqrt{6}} \vert 1 \rangle
  \biggr) \otimes \vert 0\rangle
  + \biggl(
    -\frac{1}{\sqrt{6}} \vert 0 \rangle
    +\frac{1}{\sqrt{6}} \vert 1\rangle
  \biggr) \otimes \vert 1\rangle.
\]</div>
<p><span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の測定結果 <span class="math notranslate nohighlight">\(0\)</span> が得られる確率は</p>
<div class="math notranslate nohighlight">
\[
\biggl\| \frac{1}{\sqrt{2}} \vert 0 \rangle
    + \frac{i}{\sqrt{6}} \vert 1 \rangle \biggr\|^2
= \frac{1}{2} + \frac{1}{6} = \frac{2}{3},
\]</div>
<p>この場合、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の状態は次のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \frac{\frac{1}{\sqrt{2}} \vert 0 \rangle
    + \frac{i}{\sqrt{6}} \vert 1 \rangle}{\sqrt{\frac{2}{3}}} \otimes \vert 0 \rangle
  = \biggl(\sqrt{\frac{3}{4}} \vert 0 \rangle + \frac{i}{2} \vert 1 \rangle\biggr) \otimes\vert 0 \rangle;
\]</div>
<p>測定結果が <span class="math notranslate nohighlight">\(1\)</span> である確率は</p>
<div class="math notranslate nohighlight">
\[
  \biggl\|
    -\frac{1}{\sqrt{6}} \vert 0 \rangle
    +\frac{1}{\sqrt{6}} \vert 1\rangle
  \biggr\|^2
  = \frac{1}{6} + \frac{1}{6} = \frac{1}{3},
\]</div>
<p>この場合、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の状態は次のようになります。</p>
<div class="math notranslate nohighlight">
\[
\frac{
  -\frac{1}{\sqrt{6}} \vert 0 \rangle
    +\frac{1}{\sqrt{6}} \vert 1\rangle }{\frac{1}{\sqrt{3}}}
  \otimes \vert 1\rangle
  = \biggl(-\frac{1}{\sqrt{2}} \vert 0\rangle
  + \frac{1}{\sqrt{2}} \vert 1\rangle\biggr) \otimes \vert 1\rangle.
\]</div>
</section>
<section id="id25">
<h4>縮約量子状態について<a class="headerlink" href="#id25" title="Link to this heading">#</a></h4>
<p>この例は、量子情報の簡略的な記述の限界を示しています。それは、確率的な場合のように、2つのシステムのうちの1つだけ（あるいは任意の数のシステムの部分集合）の縮約（あるいは周辺）量子状態を記述する方法がないことです。</p>
<p>具体的にいうと、2つのシステムの確率ベクトル <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> で記述される確率的状態について、以下のように書きました。</p>
<div class="math notranslate nohighlight">
\[
  \vert \psi \rangle
  = \sum_{(a,b)\in\Sigma\times\Gamma}
  p_{ab} \vert ab\rangle,
\]</div>
<p><span class="math notranslate nohighlight">\(\mathsf{X}\)</span> だけの<em>縮約</em>(または<em>周辺</em>) 状態は、次の確率ベクトルによって記述されます。</p>
<div class="math notranslate nohighlight">
\[
  \sum_{(a,b)\in\Sigma\times\Gamma} p_{ab} \vert a\rangle.
\]</div>
<p>量子状態ベクトルの場合、類似はなく — 量子状態ベクトルは、以下のようになり、</p>
<div class="math notranslate nohighlight">
\[
  \vert \phi \rangle = \sum_{(a,b)\in\Sigma\times\Gamma} \alpha_{ab} \vert ab\rangle,
\]</div>
<p>ベクトル</p>
<div class="math notranslate nohighlight">
\[
  \vert \phi \rangle = \sum_{(a,b)\in\Sigma\times\Gamma} \alpha_{ab} \vert a\rangle
\]</div>
<p>は一般に量子状態ベクトルではなく、縮約状態または周辺状態の概念を適切に表していません。実際、このベクトルはゼロベクトルである可能性があります。</p>
<p>したがって、代わりに、量子情報の一般的な記述法に目を向ける必要があります。ユニット 3 で説明するように、量子情報の一般的な記述法は、確率論的設定に類似した縮約量子状態を定義することのできる方法です。</p>
</section>
<section id="id26">
<h4>3 つ以上のシステムの部分測定<a class="headerlink" href="#id26" title="Link to this heading">#</a></h4>
<p>システムのいくつかの部分集合が測定される 3 つ以上のシステムの部分的な測定は、システムを 2 つのコレクション (測定されるものと測定されないもの) に分割することによって、2 つのシステムの場合に減らすことができます。</p>
<p>これを行う方法を示す具体的な例を次に示します。これは、それらが表すシステムの名前によるケットの添字付けがいかに有用であるかを示しています。</p>
<p>例として、5 つのシステム <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_5\)</span> の量子状態があり、すべてが同じ古典的な状態の集合 <span class="math notranslate nohighlight">\(\{\clubsuit,\diamondsuit,\heartsuit,\spadesuit\}\)</span> を共有している場合を考えます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{gathered}
\sqrt{\frac{1}{7}}
\vert\heartsuit\rangle \vert\clubsuit\rangle \vert\diamondsuit\rangle \vert\spadesuit\rangle \vert\spadesuit\rangle
+
\sqrt{\frac{2}{7}}
\vert\diamondsuit\rangle \vert\clubsuit\rangle \vert\diamondsuit\rangle \vert\spadesuit\rangle \vert\clubsuit\rangle
+
\sqrt{\frac{1}{7}}
\vert\spadesuit\rangle \vert\spadesuit\rangle \vert\clubsuit\rangle \vert\diamondsuit\rangle \vert\clubsuit\rangle
\\
-i
\sqrt{\frac{2}{7}}
\vert\heartsuit\rangle \vert\clubsuit\rangle \vert\diamondsuit\rangle \vert\heartsuit\rangle \vert\heartsuit\rangle
-
\sqrt{\frac{1}{7}}
\vert\spadesuit\rangle \vert\heartsuit\rangle \vert\clubsuit\rangle \vert\spadesuit\rangle \vert\clubsuit\rangle.
\end{gathered}
\end{split}\]</div>
<p>1 番目と 3 番目のシステムを測定し、残りのシステムを放置する状況を考えます。概念的に言えば、この状況と 2 つのシステムのうちの 1 つが測定される状況との間に基本的な違いはありませんが、残念ながら、測定されるシステムと測定されないシステムが混在しているため、これらの計算を実行するために必要な式を書き留めるのにハードルがあります。 先に述べたように、どのシステムを参照しているかを示すためにケットに添字を付けます。これにより、次に説明するように、順序を自由に変更できます。</p>
<p>まず、上記の量子状態ベクトルは、次のように書くこともできます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{gathered}
\sqrt{\frac{1}{7}}
\vert\heartsuit\rangle_1 \vert\clubsuit\rangle_2 \vert\diamondsuit\rangle_3 \vert\spadesuit\rangle_4 \vert\spadesuit\rangle_5
+
\sqrt{\frac{2}{7}}
\vert\diamondsuit\rangle_1 \vert\clubsuit\rangle_2 \vert\diamondsuit\rangle_3 \vert\spadesuit\rangle_4 \vert\clubsuit\rangle_5
+
\sqrt{\frac{1}{7}}
\vert\spadesuit\rangle_1 \vert\spadesuit\rangle_2 \vert\clubsuit\rangle_3 \vert\diamondsuit\rangle_4 \vert\clubsuit\rangle_5\\
-i
\sqrt{\frac{2}{7}}
\vert\heartsuit\rangle_1 \vert\clubsuit\rangle_2 \vert\diamondsuit\rangle_3 \vert\heartsuit\rangle_4 \vert\heartsuit\rangle_5
-
\sqrt{\frac{1}{7}}
\vert\spadesuit\rangle_1 \vert\heartsuit\rangle_2 \vert\clubsuit\rangle_3 \vert\spadesuit\rangle_4 \vert\clubsuit\rangle_5.
\end{gathered}
\end{split}\]</div>
<p>各ケットに対応するシステムを示す添字をつけたこと以外は、何も変更されていません。ここでは下付き文字 <span class="math notranslate nohighlight">\(1,\ldots,5\)</span> を使用しましたが、システム自体の名前を使用することもできます ( <span class="math notranslate nohighlight">\(\mathsf{X}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{Z}\)</span> などのシステム名がある場合)。</p>
<p>次に、ケットを並べ替えて、次のように項を収集できます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp; 
\sqrt{\frac{1}{7}}
\vert\heartsuit\rangle_1 \vert\diamondsuit\rangle_3 \vert\clubsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\spadesuit\rangle_5
+
\sqrt{\frac{2}{7}}
\vert\diamondsuit\rangle_1 \vert\diamondsuit\rangle_3 \vert\clubsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\clubsuit\rangle_5
+
\sqrt{\frac{1}{7}}
\vert\spadesuit\rangle_1 \vert\clubsuit\rangle_3 \vert\spadesuit\rangle_2 \vert\diamondsuit\rangle_4 \vert\clubsuit\rangle_5 \\
&amp; \quad -i
\sqrt{\frac{2}{7}}
\vert\heartsuit\rangle_1 \vert\diamondsuit\rangle_3 \vert\clubsuit\rangle_2 \vert\heartsuit\rangle_4 \vert\heartsuit\rangle_5
-
\sqrt{\frac{1}{7}}
\vert\spadesuit\rangle_1 \vert\clubsuit\rangle_3 \vert\heartsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\clubsuit\rangle_5\\[2mm]
&amp; \hspace{1.5cm} = \vert\heartsuit\rangle_1 \vert\diamondsuit\rangle_3 
\biggl(
\sqrt{\frac{1}{7}} \vert\clubsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\spadesuit\rangle_5
-i \sqrt{\frac{2}{7}} \vert\clubsuit\rangle_2 \vert\heartsuit\rangle_4 \vert\heartsuit\rangle_5
\biggr)\\
&amp; \hspace{1.5cm} \quad
+ \vert\diamondsuit\rangle_1 \vert\diamondsuit\rangle_3 
\biggl(
\sqrt{\frac{2}{7}} \vert\clubsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\clubsuit\rangle_5 
\biggr)\\
&amp; \hspace{1.5cm} \quad + \vert\spadesuit\rangle_1 \vert\clubsuit\rangle_3
\biggl(
\sqrt{\frac{1}{7}} \vert\spadesuit\rangle_2 \vert\diamondsuit\rangle_4 \vert\clubsuit\rangle_5
- \sqrt{\frac{1}{7}} \vert\heartsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\clubsuit\rangle_5\biggr).
\end{aligned}
\end{split}\]</div>
<p>(この例のように括弧が使用されている場合でも、テンソル積であることは暗黙の了解です。)</p>
<p>システム <span class="math notranslate nohighlight">\(\mathsf{X}_1\)</span> と <span class="math notranslate nohighlight">\(\mathsf{X}_3\)</span> が測定される場合、異なる結果の (ゼロでない) 確率は次のようになります。</p>
<ul class="simple">
<li><p>測定結果 <span class="math notranslate nohighlight">\((\heartsuit,\diamondsuit)\)</span> は次の確率で発生します</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
  \biggl\|
  \sqrt{\frac{1}{7}} \vert\clubsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\spadesuit\rangle_5
-i \sqrt{\frac{2}{7}} \vert\clubsuit\rangle_2 \vert\heartsuit\rangle_4 \vert\heartsuit\rangle_5
  \biggr\|^2 = \frac{1}{7} + \frac{2}{7} = \frac{3}{7}
  \]</div>
<ul class="simple">
<li><p>測定結果 <span class="math notranslate nohighlight">\((\diamondsuit,\diamondsuit)\)</span> は次の確率で発生します</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
  \biggl\|
  \sqrt{\frac{2}{7}} \vert\clubsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\clubsuit\rangle_5
  \biggr\|^2 = \frac{2}{7}
  \]</div>
<ul class="simple">
<li><p>測定結果 <span class="math notranslate nohighlight">\((\spadesuit,\clubsuit)\)</span> は次の確率で発生します</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
   \biggl\|
\sqrt{\frac{1}{7}} \vert\spadesuit\rangle_2 \vert\diamondsuit\rangle_4 \vert\clubsuit\rangle_5
- \sqrt{\frac{1}{7}} \vert\heartsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\clubsuit\rangle_5
   \biggr\|^2 = \frac{1}{7} + \frac{1}{7} = \frac{2}{7}.
   \]</div>
<p>たとえば、測定結果が <span class="math notranslate nohighlight">\((\heartsuit,\diamondsuit)\)</span> の場合、<span class="math notranslate nohighlight">\((\mathsf{X}_1,\ldots,\mathsf{X}_5)\)</span> の状態は次のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp; \vert \heartsuit\rangle_1 \vert \diamondsuit \rangle_3
\otimes
\frac{
\sqrt{\frac{1}{7}}
\vert\clubsuit\rangle_2 \vert\spadesuit\rangle_4 \vert\spadesuit\rangle_5
- i
\sqrt{\frac{2}{7}}
\vert\clubsuit\rangle_2 \vert\heartsuit\rangle_4 \vert\heartsuit\rangle_5}
{\sqrt{\frac{3}{7}}}\\
&amp; \qquad
= 
\sqrt{\frac{1}{3}}
\vert \heartsuit\rangle_1 \vert\clubsuit\rangle_2 \vert \diamondsuit \rangle_3\vert\spadesuit\rangle_4 \vert\spadesuit\rangle_5
-i
\sqrt{\frac{2}{3}}
\vert \heartsuit\rangle_1 \vert\clubsuit\rangle_2 \vert \diamondsuit \rangle_3\vert\heartsuit\rangle_4 \vert\heartsuit\rangle_5.
\end{aligned}
\end{split}\]</div>
<p>他の測定結果についても、同様の方法で状態を決定できます。</p>
<p>ここで、テンソル積は可換ではないことを理解する必要があります: <span class="math notranslate nohighlight">\(\vert \phi\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert \pi \rangle\)</span> がベクトルの場合、一般に <span class="math notranslate nohighlight">\(\vert \phi\rangle\otimes\vert \pi \rangle\)</span> は <span class="math notranslate nohighlight">\(\vert \pi\rangle\otimes\vert \phi \rangle\)</span> とは異なり、3 つ以上のベクトルのテンソル積についても同様です。たとえば、 <span class="math notranslate nohighlight">\(\vert\heartsuit\rangle \vert\clubsuit\rangle \vert\diamondsuit\rangle \vert\spadesuit\rangle \vert\spadesuit\rangle\)</span> は <span class="math notranslate nohighlight">\(\vert\heartsuit\rangle \vert\diamondsuit\rangle \vert\clubsuit\rangle \vert\spadesuit\rangle \vert\spadesuit\rangle\)</span> とは異なるベクトルです。 ケットの並べ替えについて説明した手法は、別の方法を示唆していると解釈されるべきではありません。むしろ、計算を実行して結果を表現するために、システム <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_5\)</span> をまとめて <span class="math notranslate nohighlight">\((\mathsf{X}_1,\mathsf{X}_2,\mathsf{X}_3,\mathsf{X}_4,\mathsf{X}_5)\)</span> ではなく、 <span class="math notranslate nohighlight">\((\mathsf{X}_1,\mathsf{X}_3,\mathsf{X}_2,\mathsf{X}_4,\mathsf{X}_5)\)</span> とします。 ケットの添字は、ここれを整理するためのものです。</p>
<p>同様に、より単純なデカルト積と順序対の設定では、 <span class="math notranslate nohighlight">\(a\)</span> と <span class="math notranslate nohighlight">\(b\)</span> が異なる古典状態であれば、 <span class="math notranslate nohighlight">\((a,b)\)</span> と <span class="math notranslate nohighlight">\((b,a)\)</span> も異なる状態です。<br>しかし、2つのビット <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の古典状態が <span class="math notranslate nohighlight">\((1,0)\)</span> であると言うことは、次のことと等価です：<br> <span class="math notranslate nohighlight">\((\mathsf{Y},\mathsf{X})\)</span> の古典的状態は <span class="math notranslate nohighlight">\((0,1)\)</span> です。すべてのシステムが固有の名前を持つとき、その順序さえはっきりしていれば、どのような順序で並べるかはあまり問題にはならないのです。</p>
<p>最後に、前に約束したように、GHZ 状態と W 状態を含む 2 つの例を次に示します。まず、GHZ状態を考えてみましょう</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\sqrt{2}} \vert 000\rangle + \frac{1}{\sqrt{2}} \vert 111\rangle.
\]</div>
<p>最初のシステムだけを測定すると、確率 <span class="math notranslate nohighlight">\(1/2\)</span> で結果 <span class="math notranslate nohighlight">\(0\)</span> が得られます。この場合、3 量子ビットの状態は <span class="math notranslate nohighlight">\(\vert 000\rangle\)</span> になります。また、確率 <span class="math notranslate nohighlight">\(1/2\)</span> で結果 <span class="math notranslate nohighlight">\(1\)</span> を取得します。この場合、3 量子ビットの状態は <span class="math notranslate nohighlight">\(\vert 111\rangle\)</span> になります。</p>
<p>次に、次のように記述できる W 状態を考えてみましょう。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp;
\frac{1}{\sqrt{3}} \vert 001\rangle +
\frac{1}{\sqrt{3}} \vert 010\rangle +
\frac{1}{\sqrt{3}} \vert 100\rangle \\
&amp; \qquad
= \vert 0 \rangle \biggl(
\frac{1}{\sqrt{3}} \vert 01\rangle +
\frac{1}{\sqrt{3}} \vert 10\rangle\biggr)
+ \vert 1 \rangle \biggl(\frac{1}{\sqrt{3}}\vert 00\rangle\biggr).
\end{aligned}
\end{split}\]</div>
<p>したがって、最初の量子ビットの測定結果が 0 になる確率は、次のようになります。</p>
<div class="math notranslate nohighlight">
\[
\biggl\|
\frac{1}{\sqrt{3}} \vert 01\rangle +
\frac{1}{\sqrt{3}} \vert 10\rangle
\biggr\|^2 = \frac{2}{3},
\]</div>
<p>この結果を生成する測定を条件として、3 量子ビットの量子状態は次のようになります。</p>
<div class="math notranslate nohighlight">
\[
\vert 0\rangle\otimes
  \frac{
    \frac{1}{\sqrt{3}} \vert 01\rangle +
    \frac{1}{\sqrt{3}} \vert 10\rangle
  }{
    \sqrt{\frac{2}{3}}
  }
  = \vert 0\rangle \biggl(\frac{1}{\sqrt{2}} \vert 01\rangle
    + \frac{1}{\sqrt{2}} \vert 10\rangle \biggr)
  = \vert 0\rangle\vert \psi^+\rangle.
\]</div>
<p>測定結果が 1 になる確率は <span class="math notranslate nohighlight">\(1/3\)</span> で、この場合、3 量子ビットの状態は <span class="math notranslate nohighlight">\(\vert 100\rangle\)</span> になります。</p>
</section>
</section>
<section id="id27">
<h3>2.3 ユニタリー演算 <a id="multiple-systems-quantum-operations"></a><a class="headerlink" href="#id27" title="Link to this heading">#</a></h3>
<p>この授業の前の章では、デカルト積を使用して、個々のシステムをより大きな単一のシステムとして扱いました。同じ考え方に従って、複数のシステムでの演算を、このより大きなシステムの状態ベクトルに作用するユニタリー行列として表すことができます。</p>
<p>原理的には、行と列が古典的な状態に対応するユニタリー行列であれば、どのようなシステムであっても量子演算は有効であり、個々のシステムの古典的状態の集合のデカルト積である合成システムの場合も同様です。</p>
<p>2つのシステムに注目すると、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が古典状態の集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> を持つシステム、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が古典状態集合 <span class="math notranslate nohighlight">\(\Gamma\)</span> を持つシステムであれば、合成システムの古典状態の集合 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> は <span class="math notranslate nohighlight">\(\Sigma\times\Gamma\)</span> です。 したがって、この合成システムに対して実行可能な演算の集合は、行と列が集合 <span class="math notranslate nohighlight">\(\Sigma\times\Gamma\)</span> に対応するように配置されたユニタリー行列で表現されます。この行列の行と列の並びは、システム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の量子状態ベクトルに用いられる並びと同じです。</p>
<p>例えば、 <span class="math notranslate nohighlight">\(\Sigma = \{1,2,3\}\)</span> と <span class="math notranslate nohighlight">\(\Gamma = \{0,1\}\)</span> とすると、デカルト積 <span class="math notranslate nohighlight">\(\{1,2,3\}\times\{0,1\}\)</span> の要素の順番は、 <span class="math notranslate nohighlight">\((1,0)\)</span>, <span class="math notranslate nohighlight">\((1,1)\)</span>, <span class="math notranslate nohighlight">\((2,0)\)</span>, <span class="math notranslate nohighlight">\((2,1)\)</span>, <span class="math notranslate nohighlight">\((3,0)\)</span>, <span class="math notranslate nohighlight">\((3,1)\)</span> が標準です。<br>以下は、 <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> 上の演算を表すユニタリー行列の例です。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U = 
\begin{pmatrix}
  \frac{1}{2} &amp; \frac{1}{2} &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; \frac{1}{2} \\
  \frac{1}{2} &amp; \frac{i}{2} &amp; -\frac{1}{2} &amp; 0 &amp; 0 &amp; -\frac{i}{2} \\
  \frac{1}{2} &amp; -\frac{1}{2} &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; -\frac{1}{2} \\
  0 &amp; 0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; 0\\
  \frac{1}{2} &amp; -\frac{i}{2} &amp; -\frac{1}{2} &amp; 0 &amp; 0 &amp; \frac{i}{2} \\
  0 &amp; 0 &amp; 0 &amp;  -\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; 0
\end{pmatrix}.
\end{split}\]</div>
<p>このユニタリー演算には特別な意味はありませんが、 <span class="math notranslate nohighlight">\(U^{\dagger} U = \mathbb{1}\)</span> であることを確認できるので、 <span class="math notranslate nohighlight">\(U\)</span> はユニタリーです。</p>
<p>たとえば、標準基底ベクトル <span class="math notranslate nohighlight">\(\vert 11 \rangle\)</span> に <span class="math notranslate nohighlight">\(U\)</span> を作用させると次のようになります。</p>
<div class="math notranslate nohighlight">
\[
U \vert 11\rangle =
\frac{1}{2} \vert 10 \rangle
+ \frac{i}{2} \vert 11 \rangle
- \frac{1}{2} \vert 20 \rangle
- \frac{i}{2} \vert 30\rangle,
\]</div>
<p>これは、集合 <span class="math notranslate nohighlight">\(\{1,2,3\}\times\{0,1\}\)</span> の順序を考慮して、 <span class="math notranslate nohighlight">\(U\)</span> の 2 番目の列を調べることで確認できます。</p>
<p>他の行列と同様に、 <span class="math notranslate nohighlight">\(U\)</span> の 20 個の非ゼロの要素に対して 20 個の項を使用するディラック表記法を使用して、 <span class="math notranslate nohighlight">\(U\)</span> を表すことができます。ただし、 <span class="math notranslate nohighlight">\(6\times 6\)</span> 行列を書くのではなく、これらの項をすべて書き留めると、行列式から明らかな特定のパターンを見逃す可能性があります。簡単に言えば、行列を表現する方法としてディラック表記が常に最良の選択であるとは限りません。</p>
<p>3 つ以上のシステムに対するユニタリー演算は、システムの古典的な状態の集合のデカルト積に対応する行と列を持つユニタリー行列で、同じように働きます。</p>
<p>この授業で既にみた例では、3 量子ビット演算には次の例があります。</p>
<div class="math notranslate nohighlight">
\[
\sum_{k = 0}^{7} \vert (k+1) \bmod 8 \rangle \langle k \vert
\]</div>
<p>ここで、 <span class="math notranslate nohighlight">\(\vert j \rangle\)</span> は、数値 <span class="math notranslate nohighlight">\(j\)</span> の 3 ビット バイナリーエンコードがユニタリーであることを意味します。ユニタリーで決定論的な演算を表す演算は、<em>可逆</em>演算と呼ばれます。この行列の共役転置は、次のように記述できます。</p>
<div class="math notranslate nohighlight">
\[
\sum_{k = 0}^{7} \vert k \rangle \langle (k+1) \bmod 8 \vert
=
\sum_{k = 0}^{7} \vert (k-1) \bmod 8 \rangle \langle k \vert.
\]</div>
<p>この行列は、元の演算の<em>逆(reverse)</em>、または数学用語で*逆(inverse)*を表します。これは、ユニタリー行列の共役転置から期待されるものです。</p>
<p>この先の授業で、複数のシステムでのユニタリー演算の他の例をみていきます。</p>
<section id="id28">
<h4>個々のシステムで独立して実行されるユニタリー演算<a class="headerlink" href="#id28" title="Link to this heading">#</a></h4>
<p>ユニタリー演算が個々のシステムのコレクションに対して独立して実行される場合、これらの独立した演算の合成作用は、それらを表すユニタリー行列のテンソル積によって記述されます。つまり、 <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> が量子システムの場合、 <span class="math notranslate nohighlight">\(U_1,\ldots, U_n\)</span> はこれらのシステムへの演算を表すユニタリー行列であり、演算は独立して実行され、 <span class="math notranslate nohighlight">\((\mathsf{X}_1,\ldots,\mathsf{X}_n)\)</span> に対する合成作用は、行列 <span class="math notranslate nohighlight">\(U_1\otimes\cdots\otimes U_n\)</span> で表されます。繰り返しますが、確率論的設定と量子設定はこの点で類似していることがわかります。</p>
<p>前の段落を読んで、ユニタリー行列の任意の集まりのテンソル積がユニタリーであることが当然予想されます。確かにこれは正しく、次のように検証できます。</p>
<p>まず、共役転置演算が以下を満たすことに注目しましょう。</p>
<div class="math notranslate nohighlight">
\[
  (M_1 \otimes \cdots \otimes M_n)^{\dagger} = M_1^{\dagger} \otimes \cdots \otimes M_n^{\dagger}
\]</div>
<p>これは、テンソル積と共役転置の定義に戻り、方程式の両側の各要素が一致していることを確認することで確認できます。これは次を意味します。</p>
<div class="math notranslate nohighlight">
\[
 (U_1 \otimes \cdots \otimes U_n)^{\dagger} (U_1\otimes\cdots\otimes U_n)
 = (U_1^{\dagger} \otimes \cdots \otimes U_n^{\dagger}) (U_1\otimes\cdots\otimes U_n).
\]</div>
<p>行列のテンソル積は乗法なので、次のようになります。</p>
<div class="math notranslate nohighlight">
\[
  (U_1^{\dagger} \otimes \cdots \otimes U_n^{\dagger}) (U_1\otimes\cdots\otimes U_n)
  = (U_1^{\dagger} U_1) \otimes \cdots \otimes (U_n^{\dagger} U_n)
  = \mathbb{1}_1 \otimes \cdots \otimes \mathbb{1}_n.
\]</div>
<p>ここで、システム <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> 上の恒等演算を表す行列を <span class="math notranslate nohighlight">\(\mathbb{1}_1,\ldots,\mathbb{1}_n\)</span> と書きました。 つまり、これらはサイズが  <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> の古典的な状態の数と一致する恒等行列です。</p>
<p>最後に、テンソル積 <span class="math notranslate nohighlight">\(\mathbb{1}_1 \otimes \cdots \otimes \mathbb{1}_n\)</span> は恒等行列に等しく、ここで行と列の数は、行列 <span class="math notranslate nohighlight">\(\mathbb{1}_1,\ldots,\mathbb{1}_n\)</span> の行と列の数の積に一致します。この大きな恒等行列は、合成システム <span class="math notranslate nohighlight">\((\mathsf{X}_1,\ldots,\mathsf{X}_n)\)</span> 上の恒等演算を表すものと見なすことができます。</p>
<p>要約すると、次の一連の等式になります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
  &amp; (U_1 \otimes \cdots \otimes U_n)^{\dagger} (U_1\otimes\cdots\otimes U_n) \\
  &amp; \quad = (U_1^{\dagger} \otimes \cdots \otimes U_n^{\dagger}) (U_1\otimes\cdots\otimes U_n) \\
  &amp; \quad = (U_1^{\dagger} U_1) \otimes \cdots \otimes (U_n^{\dagger} U_n)\\
  &amp; \quad = \mathbb{1}_{1} \otimes \cdots \otimes \mathbb{1}_{n}\\
  &amp; \quad = \mathbb{1}.
\end{aligned}
\end{split}\]</div>
<p>したがって、 <span class="math notranslate nohighlight">\(U_1 \otimes \cdots \otimes U_n\)</span> はユニタリーであると結論付けられます。</p>
<p>よくある重要な状況は、より大きな合成システムの中の1つのシステム、あるいはシステムの部分集合に単一演算を適用する場合です。例えば、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> を合わせて一つの複合システム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> と見なし、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> のシステムにのみ演算を施すとします。正確には、 <span class="math notranslate nohighlight">\(U\)</span> が <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に対する演算を表すユニタリー行列で、その行と列が <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の古典的状態に対応して配置されているとします。</p>
<p><span class="math notranslate nohighlight">\(U\)</span> で表される演算をシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> だけで行うということは、<span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> には何もしないということであり、 <span class="math notranslate nohighlight">\(U\)</span> を <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> で、 <em>恒等演算</em> を <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> で独立に行っているということです。つまり、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に対して「何もしない」ということは、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に対して恒等演算を行うことと等しく、恒等行列 <span class="math notranslate nohighlight">\(\mathbb{1}_\mathsf{Y}\)</span> で表現されることになります。(ここで、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の添え字は <span class="math notranslate nohighlight">\(\mathbb{1}_\mathsf{Y}\)</span> が <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の古典状態の集合と一致する行と列数を持つ恒等行列であることを表しています)。したがって、 <span class="math notranslate nohighlight">\(U\)</span> を <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に対して行い、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> を何もしない場合に得られる <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の演算はユニタリー行列で表現されることになります。</p>
<div class="math notranslate nohighlight">
\[
  U \otimes \mathbb{1}_{\mathsf{Y}}.
\]</div>
<p>たとえば、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が量子ビットの場合、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に対してアダマール演算を実行する (そして <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> には何もしない) ことは、合成システム <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span>に対して、</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  H \otimes \mathbb{1}_{\mathsf{Y}} = 
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  \otimes 
  \begin{pmatrix}
    1 &amp; 0\\
    0 &amp; 1
  \end{pmatrix}
  =
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; 0\\
    0 &amp; \frac{1}{\sqrt{2}} &amp; 0 &amp; \frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}} &amp; 0 &amp; -\frac{1}{\sqrt{2}} &amp; 0\\
    0 &amp; \frac{1}{\sqrt{2}} &amp; 0 &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
\end{split}\]</div>
<p>の演算を実行することと等しいです。</p>
<p>同様に、ユニタリー行列 <span class="math notranslate nohighlight">\(U\)</span> で表される演算が <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に適用され、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> には何も行われない場合も考えることができます。この場合、 <span class="math notranslate nohighlight">\(( \mathsf{X},\mathsf{Y})\)</span> に対する演算は、以下のユニタリー行列で表されます。</p>
<div class="math notranslate nohighlight">
\[
  \mathbb{1}_{\mathsf{X}} \otimes U.
\]</div>
<p>たとえば、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> の両方が量子ビットであり、 <span class="math notranslate nohighlight">\(U\)</span> がアダマール演算である状況をもう一度考えると、<span class="math notranslate nohighlight">\((\mathsf{X}, \mathsf{Y})\)</span> に対する演算は以下の行列で表されます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
    1 &amp; 0\\
    0 &amp; 1
  \end{pmatrix}
  \otimes
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix} 
  =
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; 0 &amp; 0\\
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}\\
    0 &amp; 0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}.
\end{split}\]</div>
<p>システム <span class="math notranslate nohighlight">\(\mathsf{X}_1,\ldots,\mathsf{X}_n\)</span> の集合に対するユニタリー演算は、これらのシステムの量子状態ベクトルがすべて積状態でないように、全てがユニタリー演算のテンソル積 <span class="math notranslate nohighlight">\(U_1\otimes\cdots\otimes U_n\)</span> として記述できるわけではないことが知られています。たとえば、以下で説明する 2 量子ビットに対するスワップ演算や制御NOT 演算は、ユニタリー演算のテンソル積として表すことはできません。</p>
</section>
<section id="id29">
<h4>スワップ演算<a class="headerlink" href="#id29" title="Link to this heading">#</a></h4>
<p>授業を締めくくるために、複数システムでのユニタリー演算の例を 2 つ見てみましょう。<em>スワップ演算</em>から始めます。</p>
<p><span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が、同じ古典的な状態セット <span class="math notranslate nohighlight">\(\Sigma\)</span> を共有するシステムであるとします。ペア <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> の<em>スワップ</em>操作は、2 つのシステムの内容を交換する操作ですが、それ以外の場合はシステムをそのままにしておきます (したがって、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> は左側に、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が右側に残ります)。</p>
<p>この演算を <span class="math notranslate nohighlight">\(\operatorname{SWAP}\)</span> と書き、古典的な状態 <span class="math notranslate nohighlight">\(a,b\in\Sigma\)</span> のすべての選択に対して、次のように操作します。</p>
<div class="math notranslate nohighlight">
\[
\operatorname{SWAP} \vert a \rangle \vert b \rangle = \vert b \rangle \vert a \rangle.
\]</div>
<p>ディラック表記を使用して、この演算に関連付けられた行列を記述する 1 つの方法は次のとおりです。</p>
<div class="math notranslate nohighlight">
\[
\mathrm{SWAP} = \sum_{c,d\in\Sigma} \vert c \rangle \langle d \vert \otimes \vert d \rangle \langle c \vert.
\]</div>
<p>この行列が <span class="math notranslate nohighlight">\(\operatorname{SWAP}\)</span> を表していることはすぐにはわからないかもしれませんが、古典的な状態 <span class="math notranslate nohighlight">\(a,b\in\Sigma\)</span> のすべての選択に対して、条件 <span class="math notranslate nohighlight">\(\operatorname{SWAP} \vert a \rangle \vert b \rangle = \vert b \rangle \vert a \rangle\)</span>  を満たすことを確認できます。</p>
<p>簡単な例として、  <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> と <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が量子ビットの場合、以下のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \operatorname{SWAP} =
  \begin{pmatrix}
  1 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 1 &amp; 0\\
  0 &amp; 1 &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 0 &amp; 1
  \end{pmatrix}.
\end{split}\]</div>
</section>
<section id="id30">
<h4>制御ユニタリー演算<a class="headerlink" href="#id30" title="Link to this heading">#</a></h4>
<p>ここで、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が量子ビットで、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> が任意のシステムであり、任意の古典的な状態が設定されているとします。</p>
<p>システム <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に作用するすべてのユニタリー演算 <span class="math notranslate nohighlight">\(U\)</span> に対して、<em>制御</em> <span class="math notranslate nohighlight">\(U\)</span> 演算とは、次のように定義されたペア <span class="math notranslate nohighlight">\((\mathsf{X},\mathsf{Y})\)</span> に対するユニタリー演算です。 :</p>
<div class="math notranslate nohighlight">
\[
CU =
\vert 0\rangle \langle 0\vert \otimes \mathbb{1}_{\mathsf{Y}} + \vert 1\rangle \langle 1\vert \otimes U.
\]</div>
<p>たとえば、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> も量子ビットであり、パウリ x 演算を <span class="math notranslate nohighlight">\(X = \sigma_x\)</span> と表すと、制御 <span class="math notranslate nohighlight">\(X\)</span> 演算は次のように与えられます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  CX = 
  \vert 0\rangle \langle 0\vert \otimes \mathbb{1}_{\mathsf{Y}} + \vert 1\rangle \langle 1\vert \otimes X
  = 
  \begin{pmatrix}
  1 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 1 &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 0 &amp; 1\\
  0 &amp; 0 &amp; 1 &amp; 0
  \end{pmatrix}.
\end{split}\]</div>
<p>この演算は、以前の授業で、古典情報と確率的な演算の文脈で、すでに遭遇しています。</p>
<p>代わりに、 <span class="math notranslate nohighlight">\(X\)</span> 演算の代わりに <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> に対する パウリ z 演算を考えると、次の演算が得られます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  CZ = 
  \vert 0\rangle \langle 0\vert \otimes \mathbb{1}_{\mathsf{Y}} + \vert 1\rangle \langle 1\vert \otimes Z
  = 
  \begin{pmatrix}
  1 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 1 &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; 1 &amp; 0\\
  0 &amp; 0 &amp; 0 &amp; -1
  \end{pmatrix}.
\end{split}\]</div>
<p>代わりに、 <span class="math notranslate nohighlight">\(\mathsf{Y}\)</span> を 2 量子ビットと見なし、 <span class="math notranslate nohighlight">\(U\)</span> をこれら 2 量子ビット間の<em>スワップ演算</em>と見なすと、次の演算が得られます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \operatorname{CSWAP} = 
  \begin{pmatrix}
  1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\  
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
  \end{pmatrix}.
\end{split}\]</div>
<p>この演算は、エドワード・フレドキンにちなんで名付けられた<em>フレドキン演算</em>(または、より一般的には、<em>フレドキン ゲート</em>) としても知られています。標準基底状態に対するその作用は、次のように説明できます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{aligned}
    \operatorname{CSWAP} \vert 0 b c \rangle 
    &amp; = \vert 0 b c \rangle \\[1mm]
    \operatorname{CSWAP} \vert 1 b c \rangle 
    &amp; = \vert 1 c b \rangle
  \end{aligned}
\end{split}\]</div>
<p>最後に、 <span class="math notranslate nohighlight">\(\mathrm{cc}X\)</span> と表すことのできる<em>制御-制御</em>-NOT 操作は、<em>トフォリ演算</em>(または<em>トフォリ ゲート</em>) と呼ばれ、トマソ・トフォリ にちなんで名付けられました。その行列表現は次のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  CCX = 
  \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
  \end{pmatrix}.
\end{split}\]</div>
<p>代わりに、ディラック表記を使用して次のように表現することもできます。</p>
<div class="math notranslate nohighlight">
\[
  CCX = \bigl(
    \vert 00 \rangle \langle 00 \vert
    + \vert 01 \rangle \langle 01 \vert
    + \vert 10 \rangle \langle 10 \vert \bigr) \otimes \mathbb{1}
    + \vert 11 \rangle \langle 11 \vert \otimes X.
\]</div>
</section>
</section>
</section>
<section id="qiskit">
<h2>3. Qiskit コード例<a class="headerlink" href="#qiskit" title="Link to this heading">#</a></h2>
<p>前のページでは、Qiskitの <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> クラスと <code class="docutils literal notranslate"><span class="pre">Operator</span></code> クラスについて学び、それらを使って量子システムをシミュレートしてみました。この章では、それらを使って複数システムの振る舞いを探ります。まず、これらのクラスをインポートすることから始めます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">Statevector</span><span class="p">,</span> <span class="n">Operator</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span>
</pre></div>
</div>
</div>
</div>
<section id="id31">
<h3>3.1 テンソル積<a class="headerlink" href="#id31" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Statevector</span></code>クラスには、それ自体のテンソル積と別の<code class="docutils literal notranslate"><span class="pre">Statevector</span></code>のテンソル積を返す<code class="docutils literal notranslate"><span class="pre">tensor</span></code>メソッドがあります。</p>
<p>たとえば、以下では、 <span class="math notranslate nohighlight">\(|0\rangle\)</span> と <span class="math notranslate nohighlight">\(|1\rangle\)</span> を表す 2 つの状態ベクトルを作成し、 <code class="docutils literal notranslate"><span class="pre">tensor</span></code>メソッドを使用して新しいベクトル <span class="math notranslate nohighlight">\(|0\rangle \otimes |1\rangle\)</span> を作成します。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">zero</span><span class="p">,</span> <span class="n">one</span> <span class="o">=</span> <span class="n">Statevector</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">),</span> <span class="n">Statevector</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
<span class="n">zero</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">one</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;latex&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[ |01\rangle\]</div>
</div>
</div>
<p>以下の別の例では、 <span class="math notranslate nohighlight">\(|{+}\rangle\)</span> および <span class="math notranslate nohighlight">\(\tfrac{1}{\sqrt{2}}(|0\rangle + i|1\rangle)\)</span> 状態を表す状態ベクトルを作成し、合成して、新しい状態ベクトルを作成します。この新しいベクトルを変数<code class="docutils literal notranslate"><span class="pre">psi</span></code>に割り当てます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plus</span> <span class="o">=</span> <span class="n">Statevector</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
<span class="n">i_state</span> <span class="o">=</span> <span class="n">Statevector</span><span class="p">([</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="n">j</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">plus</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">i_state</span><span class="p">)</span>

<span class="n">psi</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;latex&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\frac{1}{2} |00\rangle+\frac{i}{2} |01\rangle+\frac{1}{2} |10\rangle+\frac{i}{2} |11\rangle\]</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Operator</span></code>クラスには<code class="docutils literal notranslate"><span class="pre">tensor</span></code>メソッドもあります。以下の例では、 <span class="math notranslate nohighlight">\(X\)</span> および <span class="math notranslate nohighlight">\(I\)</span> ゲートを作成し、それらのテンソル積を表示します。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">X</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],
          [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],
          [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
          [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]],
         input_dims=(2, 2), output_dims=(2, 2))
</pre></div>
</div>
</div>
</div>
<p>次に、前のページで単一システムで行ったように、これらの合成状態と演算を扱うことができます。たとえば、下のセルでは、上で定義した状態<code class="docutils literal notranslate"><span class="pre">psi</span></code>を使用して、<span class="math notranslate nohighlight">\((I\otimes X)|\psi\rangle\)</span> を計算します。</p>
<p>注: <code class="docutils literal notranslate"><span class="pre">^</span></code>演算子を使用して、2 つの演算子を一緒にテンソル積することもできます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">I</span> <span class="o">^</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;latex&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\frac{i}{2} |00\rangle+\frac{1}{2} |01\rangle+\frac{i}{2} |10\rangle+\frac{1}{2} |11\rangle\]</div>
</div>
</div>
<p>以下では、 <span class="math notranslate nohighlight">\(\text{CNOT}\)</span> 演算子を作成し、 <span class="math notranslate nohighlight">\(\text{CNOT}|\psi\rangle\)</span> を計算します。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">CX</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="n">psi</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">CX</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;latex&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\frac{1}{2} |00\rangle+\frac{i}{2} |01\rangle+\frac{i}{2} |10\rangle+\frac{1}{2} |11\rangle\]</div>
</div>
</div>
</section>
<section id="id32">
<h3>3.2 部分測定<a class="headerlink" href="#id32" title="Link to this heading">#</a></h3>
<p>前のページでは、 <code class="docutils literal notranslate"><span class="pre">measure</span></code>メソッドを使用して、量子状態ベクトルの測定をシミュレートしました。このメソッドは、シミュレートされた測定結果と、この測定値が与えられた新しい<code class="docutils literal notranslate"><span class="pre">Statevector</span></code>の 2 つの項目を返します。</p>
<p>デフォルトでは、 <code class="docutils literal notranslate"><span class="pre">measure</span></code>は状態ベクトル内のすべての量子ビットを測定しますが、整数のリストを指定して、それらのインデックスの量子ビットのみを測定できます。下のセルは状態 <span class="math notranslate nohighlight">\(W = \tfrac{1}{\sqrt{3}}(|001\rangle + |010\rangle + |100\rangle)\)</span> を作成します。</p>
<p>注: Qiskit は、主に量子ビットベースの量子コンピューターで使用するために設計されています。そのため、 <code class="docutils literal notranslate"><span class="pre">Statevector</span></code>は <span class="math notranslate nohighlight">\(2^n\)</span> 要素を持つベクトルを <span class="math notranslate nohighlight">\(n\)</span> 量子ビットのシステムとして解釈しようとします。コンストラクターに<code class="docutils literal notranslate"><span class="pre">dims</span></code>引数を渡すことで、これをオーバーライドできます。たとえば、 <code class="docutils literal notranslate"><span class="pre">dims=(4,2)</span></code>は Qiskit に、システムに 1 つの 4 レベル システムと 1 つの 2 レベル システム (量子ビット) があることを伝えます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="o">=</span> <span class="n">Statevector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">W</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;latex&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\frac{\sqrt{3}}{3} |001\rangle+\frac{\sqrt{3}}{3} |010\rangle+\frac{\sqrt{3}}{3} |100\rangle\]</div>
</div>
</div>
<p>以下のセルは、右端の量子ビット (インデックス 0 を持つ) の測定をシミュレートします。他の 2 つの量子ビットは測定されません。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="p">,</span> <span class="n">new_sv</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">measure</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># measure qubit 0</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Measured: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="se">\n</span><span class="s2">State after measurement:&quot;</span><span class="p">)</span>
<span class="n">new_sv</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;latex&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Measured: 0
State after measurement:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\frac{\sqrt{2}}{2} |010\rangle+\frac{\sqrt{2}}{2} |100\rangle\]</div>
</div>
</div>
<p>セルを数回実行して、色々な結果を確認してください。 <code class="docutils literal notranslate"><span class="pre">1</span></code>を測定すると、他の両方の量子ビットが <span class="math notranslate nohighlight">\(|0\rangle\)</span> であることがわかっていることを意味しますが、 <code class="docutils literal notranslate"><span class="pre">0</span></code>を測定すると、残りの 2 つの量子ビットは <span class="math notranslate nohighlight">\(\tfrac{1}{\sqrt{2}}(|01\rangle + |10\rangle)\)</span> です。</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./courses/basics"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">はじめに</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">1. 古典情報<a id="multiple-systems-classical-info"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">1.1 デカルト積による古典的状態 <a id="multiple-systems-classical-state-sets"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">状態を文字列として表す</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">1.2 確率的状態 <a id="multiple-systems-probabilistic"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">デカルト積の状態集合の順序付け</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">2 つのシステムの独立性</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">ベクトルのテンソル積</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">3 つ以上のシステムの独立性とテンソル積</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">1.3 確率的状態の測定 <a id="multiple-systems-probabilistic-measurement"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">部分測定</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">1.4 確率的状態の演算  <a id="multiple-systems-probabilistic-operations"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">独立した演算</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">行列のテンソル積</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">独立した演算（続き）</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">2. 量子情報 <a id="multiple-systems-quantum-info"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">2.1 量子状態<a id="multiple-systems-quantum-states"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">量子状態ベクトルのテンソル積</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">エンタングル状態</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">ベル状態</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ghz-w">GHZ と W 状態</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">追加の例</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">2.2 量子状態の測定 <a id="multiple-systems-quantum-measurements"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id24">2 つのシステムの部分測定</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">縮約量子状態について</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id26">3 つ以上のシステムの部分測定</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id27">2.3 ユニタリー演算 <a id="multiple-systems-quantum-operations"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id28">個々のシステムで独立して実行されるユニタリー演算</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id29">スワップ演算</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id30">制御ユニタリー演算</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#qiskit">3. Qiskit コード例</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id31">3.1 テンソル積</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id32">3.2 部分測定</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Quantum Tokyo
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright Quantum Tokyo 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>