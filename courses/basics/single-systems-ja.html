
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>単一システム &#8212; Quantum Tokyo</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="application/vnd.jupyter.widget-state+json">{"state": {"0b0352498c094d4f95c7165b5d6e1f68": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {"width": "190px"}}, "0b122aa4997c44dba6e0511aa53bc88c": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "102671dc540e4132bbecd78b691d3d05": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {"width": "70px"}}, "178aec02ef6647818ae50fc852f091cc": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HBoxModel", "state": {"children": ["IPY_MODEL_329414b8cb2c4129b028d47c55bd9870", "IPY_MODEL_74ffcd413c1b480f9a7c0ea7df1bebaf", "IPY_MODEL_c6b8e6075ac2426d9ec9e8fbbd895eb0", "IPY_MODEL_6dbc2592885646fe8480903b4e78418f", "IPY_MODEL_c42bc12a37c84b159831b65393dbc141"], "layout": "IPY_MODEL_7aad95551543437eb68e1cd693655ea2"}}, "22821a2856c74a0bad7a301b9d973d57": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "22abfc0fd6314250ad308b06ef0782ba": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {"width": "145px"}}, "2dc9d53641f14ce9a024808cbf5f5b53": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {"grid_template_areas": "\n                                       \". . . . right \"\n                                        ", "grid_template_columns": "20% 20% 20% 20% 20%", "width": "100%"}}, "329414b8cb2c4129b028d47c55bd9870": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_0b0352498c094d4f95c7165b5d6e1f68", "style": "IPY_MODEL_50dacb86249b4ae8bbc7d23cfb8def6e", "value": "<h5>Job ID</h5>"}}, "39865a7f67034821b48682c49f3d12b0": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {"grid_area": "right", "padding": "0px 0px 0px 0px", "width": "70px"}}, "453e4a775ff441528bdc9a0fc8d89c36": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {}}, "50dacb86249b4ae8bbc7d23cfb8def6e": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "5a559b4fa2d74e1d87ff75399a798c3f": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "GridBoxModel", "state": {"children": ["IPY_MODEL_f110291a776b46478976688b180e5d07"], "layout": "IPY_MODEL_2dc9d53641f14ce9a024808cbf5f5b53"}}, "631501997ff54ec1b63bea8e2c3573dd": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {"margin": "0px 0px 10px 0px"}}, "641b54c515ac48d0a490eef0185f2cba": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "ButtonStyleModel", "state": {"font_family": null, "font_size": null, "font_style": null, "font_variant": null, "font_weight": null, "text_color": null, "text_decoration": null}}, "6dbc2592885646fe8480903b4e78418f": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_102671dc540e4132bbecd78b691d3d05", "style": "IPY_MODEL_a23012bd23cb4c92a701718dff471444", "value": "<h5>Queue</h5>"}}, "6eb2dc9c933f4c5cbef0bd6cd2bf2f66": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {"width": "95px"}}, "74fd15d0710449abbcb30394d35f0c9c": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "74ffcd413c1b480f9a7c0ea7df1bebaf": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_22abfc0fd6314250ad308b06ef0782ba", "style": "IPY_MODEL_0b122aa4997c44dba6e0511aa53bc88c", "value": "<h5>Backend</h5>"}}, "7aad95551543437eb68e1cd693655ea2": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {"margin": "0px 0px 0px 37px", "width": "600px"}}, "8ee8ac34fe1f41ceacfc7aa3d11cfe43": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_631501997ff54ec1b63bea8e2c3573dd", "style": "IPY_MODEL_74fd15d0710449abbcb30394d35f0c9c", "value": "<p style='font-family: IBM Plex Sans, Arial, Helvetica, sans-serif; font-size: 20px; font-weight: medium;'>Circuit Properties</p>"}}, "a10a5c7dd29942e489bffc04598c0751": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "a23012bd23cb4c92a701718dff471444": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "c42bc12a37c84b159831b65393dbc141": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_453e4a775ff441528bdc9a0fc8d89c36", "style": "IPY_MODEL_22821a2856c74a0bad7a301b9d973d57", "value": "<h5>Message</h5>"}}, "c6b8e6075ac2426d9ec9e8fbbd895eb0": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_6eb2dc9c933f4c5cbef0bd6cd2bf2f66", "style": "IPY_MODEL_a10a5c7dd29942e489bffc04598c0751", "value": "<h5>Status</h5>"}}, "f110291a776b46478976688b180e5d07": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "ButtonModel", "state": {"button_style": "primary", "description": "Clear", "layout": "IPY_MODEL_39865a7f67034821b48682c49f3d12b0", "style": "IPY_MODEL_641b54c515ac48d0a490eef0185f2cba", "tooltip": null}}}, "version_major": 2, "version_minor": 0}</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script crossorigin="anonymous" data-jupyter-widgets-cdn="https://cdn.jsdelivr.net/npm/" src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.6/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'courses/basics/single-systems-ja';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Quantum Tokyo - Home"/>
    <img src="../../_static/logo.png" class="logo__image only-dark pst-js-only" alt="Quantum Tokyo - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Quantum Tokyo へようこそ
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">学習コンテンツ</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../get_started.html">Qiskit の始め方</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iqp_documents.html">IBM Quantum Plaform 教材 日本語訳</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ibm_research_blog.html">IBM Research Blog 日本語版</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qiskit_textbook_ja.html">Qiskitテキストブック 日本語版</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qiskit_textbook_new_ja.html">新版 Qiskitテキストブック 日本語版 (Qiskitコース)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qiskit_documents_ja.html">Qiskitドキュメント・チュートリアル 日本語版リンク集</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_challenge_ja.html">IBM Quantum Challenge 一覧</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qgss_ja.html">Qiskit Global Summer School （Qiskit夏の学校） 資料 日本語版</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_tokyo_materials.html">Quantum Tokyo 過去イベント資料</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../events.html">Qiskitコミュニティー関連イベント案内</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools.html">その他： IBM Quantum の便利なツール</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/quantum-tokyo/introduction" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/quantum-tokyo/introduction/issues/new?title=Issue%20on%20page%20%2Fcourses/basics/single-systems-ja.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/courses/basics/single-systems-ja.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>単一システム</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">はじめに</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">1.古典情報<a id="single-systems-classical"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">1.1 古典的な状態と確率ベクトル <a id="classical-states"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">1.2 確率的状態の測定 <a id="classical-measure"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">1.3 古典的な演算 <a id="classical-operations"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">決定論的演算</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">確率演算と確率行列</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">確率演算の合成</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">2. 量子情報<a id="single-systems-quantum"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">2.1 量子状態ベクトル<a id="single-systems-quantum-states"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">量子ビット状態の例</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">他の系の量子状態</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">2.2 量子状態の測定 <a id="single-systems-quantum-measure"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">2.3 ユニタリー演算 <a id="single-systems-unitary"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">量子ビットへのユニタリー演算の重要な例</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">量子ビットユニタリー演算の合成</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">大規模システムでのユニタリー演算</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#qiskit">3. Qiskit コード例</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#python">3.1 Python でのベクトルと行列</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">3.2 Qiskit での状態、測定、および操作</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">状態ベクトルの定義と表示</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#statevector"><code class="docutils literal notranslate"><span class="pre">Statevector</span></code> を使用した測定のシミュレーション</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#operator-statevector"><code class="docutils literal notranslate"><span class="pre">Operator</span></code> と <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> を使用した演算の実行</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">量子回路の先を見据えて</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>単一システム<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<section id="id2">
<h2>はじめに<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>この授業では、<a class="reference internal" href="#gloss:quantum-information"><span class="xref myst">量子情報</span></a> の基本的なフレームワークを紹介します。具体的には、複素数の要素を持つベクトルとしての量子状態の記述、量子状態から古典的な情報を抽出できるようにする測定、およびユニタリー行列によって記述される量子状態の操作が含まれます。ここでは、単一のシステムが分離されていると見なされる比較的単純な設定を扱います。この次の授業で、見方を複数のシステムに拡張し、たとえば、複数のシステムが相互に作用し、相互に関連付けられる系について学びます。</p>
<p>実際、量子情報の一般的な数学的記述は 2 つあります。この授業で紹介するのは、そのうちの単純な方です。この記述は、多くの（あるいはほとんどの）量子アルゴリズムを理解するのに十分であり、教育的な観点からも自然な出発点です。</p>
<p>より一般的で、より強力な量子情報の記述である、量子状態を <em>密度行列</em> で表現する方法については、後の授業で紹介します。密度行列の記述は、いくつかの理由から、量子情報の研究に不可欠です。例として、 <a class="reference internal" href="#gloss:altnoise"><span class="xref myst">ノイズ</span></a> の影響をモデル化するために用いることができます。また、量子力学的な計算や、エンタングルしたペアの片方の状態を表すこともできます。密度行列は量子情報理論や量子暗号の数学的な基礎となるものであり、数学的な観点からも非常に美しいものです。これらの理由から、時期が来たらもっと詳しく学ぶことをお勧めしますが、今は簡単な量子情報の記述に焦点を当てます。</p>
</section>
<section id="id3">
<h2>1.古典情報<a id="single-systems-classical"></a><a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>量子情報とその仕組みについて説明するために、まず <a class="reference internal" href="#gloss:classical"><span class="xref myst">古典</span></a> 情報の概要について説明します。読者の中には、なぜ <em>量子</em> 情報の講座で古典情報にこれほどまでに注目するのか不思議に思われるかもしれませんが、それにはちゃんとした理由があるのです。一つは、量子情報と古典情報はかなり大きく異なるものの、その数学的記述は実は非常によく似ていることです。</p>
<p>また、古典情報は、量子情報を学ぶ上で身近な存在であり、意外に多くの類似性を持った教材となります。量子情報についての質問には、古典的なアナロジーを持つものがよく出てきます。実際、古典情報を理解せずに量子情報を理解することはできないと主張することは、決して不合理なことではありません。</p>
<p>本章の内容は、既にご存知の方もいらっしゃれば、そうでない方もいらっしゃるかもしれませんが、どちらの方にも楽しんでいただける内容となっています。本章では、量子情報入門に関連する古典的な情報を紹介するとともに、量子情報・計算の分野でベクトルや行列を記述する際によく用いられる <em>ディラック記法</em> を紹介します。ディラック記法は量子情報に特化した記法ではなく、古典情報の文脈でも、またベクトルや行列が登場する他の多くの場面でも同様に使用することができます。</p>
<section id="id4">
<h3>1.1 古典的な状態と確率ベクトル <a id="classical-states"></a><a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>情報を格納する<a class="reference internal" href="#gloss:system"><span class="xref myst">システム</span></a>があるとします。より具体的には、このシステムが各時点で有限数の <em>古典的な状態</em> のいずれかにあると仮定しましょう。ここで、「古典的な状態」という用語は、直感的に理解できるように、一義的に認識・記述可能な状態を指すものとします。</p>
<p>典型的な例は、古典的な状態が 0 と 1 であるシステムである<em>ビット</em>の例です。他の例には、1、2、3、 4、5、6のある6面ダイス；<em>A</em> 、 <em>C</em> 、 <em>G</em> 、<em>T</em>である DNAの核酸塩基；<em>高</em> 、 <em>中</em> 、 <em>低</em> 、<em>オフ</em>のある扇風機のスイッチなどが古典の状態です。数学的には、システムの古典的状態の指定が出発点となります。古典的状態0と1を持つシステムをビットと定義し、異なる古典的状態セットを持つシステムも同様にビットと定義します。</p>
<p>この議論のために、考慮しているシステムに <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> という名前を付け、記号 <span class="math notranslate nohighlight">\(\class{_sigma}{\Sigma}\)</span> を使用して古典的な状態の集合を記すことにしましょう。<span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の <span class="math notranslate nohighlight">\(\Sigma\)</span> が有限であるという仮定と同様に、前述のように、<span class="math notranslate nohighlight">\(\Sigma\)</span> が空でないことも当然仮定します。物理システムが状態をまったく持たないことは無意味です。無限に多くの古典的な状態を持つ物理システムを考慮することは理にかなっていますが、ここではこの可能性を無視します。限られた数の状態内であっても、探索すべき興味深いアイデアがたくさんあります。便宜上、簡潔にするために、これ以降、 <em>古典状態の集合</em> という用語を使用して、任意の有限で空でない集合を意味します。</p>
<p>例えば、<span class="math notranslate nohighlight">\(\mathsf{X}\)</span> がビットの場合、<span class="math notranslate nohighlight">\(\Sigma = {0,1}\)</span> (これはよく <em>バイナリー・アルファベット</em> と呼ばれます)であり、; <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が 6 面ダイスの場合、<span class="math notranslate nohighlight">\(\Sigma = {1,2,3,4,5,6}\)</span> であり、; <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が扇風機スイッチの場合、<span class="math notranslate nohighlight">\(\Sigma = {\mathrm{high}, \mathrm{medium}, \mathrm{low}, \mathrm{off}}\)</span> です。</p>
<p><span class="math notranslate nohighlight">\(\mathsf{X}\)</span> を情報の伝達手段として考えると、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> のさまざまな古典的な状態に特定の意味が割り当てられ、さまざまな結果や結果につながる可能性があります。そのような場合、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> は単に可能な古典的な状態の 1 つにあると説明するだけで十分かもしれません。たとえば、  <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が扇風機のスイッチである場合、それが <em>high</em> に設定されていることを確実に知ることができます。ただし、情報処理では、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に関する知識が不確実であることがよくあります。  <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> の古典的な状態に関する知識を、それぞれの古典的な状態に <em>確率的状態</em> を割り当てることで表します。</p>
<p>たとえば、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> がビットだとします。過去に <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に何が起こったかについて私たちが知っていること、または期待していることに基づいて、おそらく <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> は確率 <span class="math notranslate nohighlight">\(3/4\)</span> の古典的な状態 <span class="math notranslate nohighlight">\(0\)</span> にあり、確率 <span class="math notranslate nohighlight">\(1/4\)</span> で <span class="math notranslate nohighlight">\(1\)</span> の状態にあることを次のように書くことで、その信じている事柄を表すことができます。</p>
<div class="math notranslate nohighlight">
\[
\class{probability}{\operatorname{Pr}}(\mathsf{X}=0) = \frac{3}{4}
\quad\text{と}\quad
\class{probability}{\operatorname{Pr}}(\mathsf{X}=1) = \frac{1}{4}.
\]</div>
<p>この確率的状態を表すより簡潔な方法は、列ベクトルを使用することです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
  \frac{3}{4}\\[1mm]
  \frac{1}{4}
\end{pmatrix}
\end{split}\]</div>
<p>ビットが <span class="math notranslate nohighlight">\(0\)</span> である確率をベクトルの先頭に、ビットが <span class="math notranslate nohighlight">\(1\)</span> である確率を下に配置していますが、これは単に集合 <span class="math notranslate nohighlight">\(\{0,1\}\)</span> の順番で並べるのが通例であるためです。</p>
<p>一般に、古典的な状態集合を持つシステムの確率的な状態は、同じように確率のベクトルとして表現することができます。確率はどのようにでも並べることができ、それは通常、扱う古典的状態集合の自然な並び方やデフォルトの並び方によって決まります。正確には、以下の2つの性質を満たす列ベクトルによって、あらゆる確率的な状態を表現することができます：</p>
<ol class="arabic simple">
<li><p>ベクトルのすべての要素は <em>非負の実数</em> です。</p></li>
<li><p>要素の合計は <span class="math notranslate nohighlight">\(1\)</span> です。</p></li>
</ol>
<p>逆に、これら 2 つの性質を満たす列ベクトルは、確率的状態の表現と見なすことができます。以降、この形式のベクトルを <em>確率ベクトル</em> と呼ぶことにします。</p>
<p>この表記の簡潔さに加えて、確率的状態を列ベクトルとして表現することで、後述するように確率的状態に対する演算が行列とベクトルの乗算によって表されるという利点があります。</p>
</section>
<section id="id5">
<h3>1.2 確率的状態の測定 <a id="classical-measure"></a><a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p>ここで、あるシステムが確率論的状態にあるときにそれを <em>測定</em> するとどうなるかを簡単に考えてみましょう。システムを測定するということは、システムを見て、それがどのような古典的な状態にあるかを明確に認識することを意味します。直感的には、システムを確率的な状態で「見る」ことはできません。測定により、許容される古典的な状態の 1 つが正確に得られます。</p>
<p>測定はシステムに関する知識を変更し、したがってそのシステムに関連付けされた確率的状態を変更します:  <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が古典的な状態 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> にあると認識した場合、<span class="math notranslate nohighlight">\(\mathsf{X}\)</span> に関する知識を表す新しい確率ベクトルは、 <span class="math notranslate nohighlight">\(a\)</span> に対応する要素が <span class="math notranslate nohighlight">\(1\)</span> で、他のすべての要素が <span class="math notranslate nohighlight">\(0\)</span> のベクトルになります。このベクトルは、 <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が確実に古典的な状態 <span class="math notranslate nohighlight">\(a\)</span> にあることを示しており、それを認識しただけで知っていることになります。</p>
<p><span class="math notranslate nohighlight">\(\vert a\rangle\)</span> で、<span class="math notranslate nohighlight">\(a\)</span> に対応する要素に <span class="math notranslate nohighlight">\(1\)</span> を持ち、他のすべての要素に <span class="math notranslate nohighlight">\(0\)</span> を持つベクトルを意味します。このベクトルは「ケット <span class="math notranslate nohighlight">\(a\)</span>」と読みます。理由は後ほど説明します。この種のベクトルは、 <em>標準基底</em> ベクトルとも呼ばれます。</p>
<p>たとえば、私たちが考えているシステムがビットであると仮定すると、標準基底ベクトルは次のように与えられます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \vert 0\rangle = \begin{pmatrix}1\\0\end{pmatrix}
  \quad\text{と}\quad
  \vert 1\rangle = \begin{pmatrix}0\\1\end{pmatrix}.
\end{split}\]</div>
<p>任意の2次元列ベクトルは、これら2つのベクトルの線形結合として表現できることに注意してください。例えば次のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
  \frac{3}{4}\\[2mm]
  \frac{1}{4}
\end{pmatrix}
= \frac{3}{4}\,\vert 0\rangle + \frac{1}{4}\,\vert 1\rangle.
\end{split}\]</div>
<p>この事実は当然のことながら、あらゆる古典的な状態の集合に一般化されます。あらゆる列ベクトルは、古典的な状態の線形結合です。ベクトルを標準基底ベクトルの線形結合として表現することは、今後非常に一般的になります。</p>
<p>ここで、測定によって確率的な状態が変化することに話を戻すと、日常の経験と次のようなつながりがあることに気付くかもしれません。例えば、公正なコインを投げ、見る前にコインを覆ったとします。その場合、その確率的状態は次のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
  \frac{1}{2}\\[2mm]
  \frac{1}{2}
\end{pmatrix}
= \frac{1}{2}\,\vert\text{heads}\rangle + \frac{1}{2}\,\vert\text{tails}\rangle.
\end{split}\]</div>
<p>ここで、コインの古典的な状態の集合は <span class="math notranslate nohighlight">\(\{\text{heads},\text{tails}\}\)</span> です。これらの状態を表が先、裏が後の順序となるように並べることにします。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\vert\text{heads}\rangle = \begin{pmatrix}1\\0\end{pmatrix}
\quad\text{と}\quad
\vert\text{tails}\rangle = \begin{pmatrix}0\\1\end{pmatrix}
\end{split}\]</div>
<p>コインを取り出して見ると、表または裏の 2 つの古典的な状態のいずれかが表示されるはずです。結果が裏だったと仮定すると、当然、コインの確率的状態の記述を <span class="math notranslate nohighlight">\(|\text{tails}\rangle\)</span> になるように更新します。もちろん、コインを覆い隠し、覆いを取ってもう一度見ると、古典的な状態はやはり裏であり、これはベクトル <span class="math notranslate nohighlight">\(|\text{tails}\rangle\)</span> によって記述される確率的状態と一致します。 これは些細なことのように思えるかもしれませんし、ある意味ではそうです。ただし、量子システムはまったく類似した方法で動作しますが、その測定特性はしばしば普通ではない、または「不気味」と見なされます。古典的なシステムの測定特性を確立することにより、量子情報の類似した動作はそれほど珍しいものではないように見えるかもしれません。</p>
<p>確率的状態の測定に関する最後の注意: それらは知識や信念を説明している可能性があり、必ずしも実際のものとは限りません。コインをひっくり返した後、見る前のコインの状態は、表か裏かのどちらかであり、見るまでどちらかわかりません。見ることで実際に状態が変わるわけではなく、それについての私たちの知識が変わるだけです。古典的な状態が裏であることがわかると、ベクトル <span class="math notranslate nohighlight">\(|\text{tails}\rangle\)</span> をコインに割り当てることによって知識を自然に更新しますが、コインが発見されたときにコインを見なかった他の人には、確率的状態は変わらないままです。これは問題ではありません。個人によって、特定のシステムに関する知識や信念が異なる場合があるため、そのシステムを異なる確率ベクトルで表現することができます。</p>
</section>
<section id="id6">
<h3>1.3 古典的な演算 <a id="classical-operations"></a><a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>古典的な情報についての簡単な説明の最後に、古典的なシステムに対してどのような演算を行うかについて考えてみましょう。</p>
<section id="id7">
<h4>決定論的演算<a class="headerlink" href="#id7" title="Link to this heading">#</a></h4>
<p>まず、 <a class="reference internal" href="#gloss:altdeterministic"><span class="xref myst">決定論</span></a> 的な演算があり、各古典的な状態 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> は、形式 <span class="math notranslate nohighlight">\(f:\Sigma\rightarrow\Sigma\)</span> の関数 <span class="math notranslate nohighlight">\(f\)</span> で <span class="math notranslate nohighlight">\(f(a)\)</span> に変換されます。</p>
<p>たとえば、 <span class="math notranslate nohighlight">\(\Sigma = {0,1}\)</span> の場合、この形式の関数は <span class="math notranslate nohighlight">\(f_1\)</span> 、<span class="math notranslate nohighlight">\(f_2\)</span> 、<span class="math notranslate nohighlight">\(f_3\)</span> 、および <span class="math notranslate nohighlight">\(f_4\)</span> の 4 つあり、次の値の表で表すことができます :</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\rule[-10mm]{0mm}{15mm}
\begin{array}{c|c}
  a &amp; f_1(a)\\
  \hline
  0 &amp; 0\\
  1 &amp; 0
\end{array}
\qquad
\begin{array}{c|c}
  a &amp; f_2(a)\\
  \hline
  0 &amp; 0\\
  1 &amp; 1
\end{array}
\qquad
\begin{array}{c|c}
  a &amp; f_3(a)\\
  \hline
  0 &amp; 1\\
  1 &amp; 0
\end{array}
\qquad
\begin{array}{c|c}
  a &amp; f_4(a)\\
  \hline
  0 &amp; 1\\
  1 &amp; 1
\end{array}
\end{split}\]</div>
<p>これらの関数のうち、最初のものと最後のものは <em>定値</em> です: 各 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> に対して <span class="math notranslate nohighlight">\(f_1(a) = 0\)</span> と <span class="math notranslate nohighlight">\(f_4(a) = 1\)</span> 。真ん中の 2 つは定値ではなく、 <em>分布</em> しています。これは、2 つの可能な出力値が、可能な入力の範囲内で同じ回数発生するという意味です。関数 <span class="math notranslate nohighlight">\(f_2\)</span> は <a class="reference internal" href="#gloss:identity-function"><span class="xref myst">恒等関数</span></a> です: 各 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> に対して <span class="math notranslate nohighlight">\(f_2(a) = a\)</span> 。 <span class="math notranslate nohighlight">\(f_3\)</span> は関数 <span class="math notranslate nohighlight">\(f_3(0) = 1\)</span> および <span class="math notranslate nohighlight">\(f_3(1) = 0\)</span> であり、NOT 関数としてよく知られています。</p>
<p>確率的状態に対する決定論的演算の行為は、行列とベクトルの乗算で表すことができます。具体的には、与えられた関数 <span class="math notranslate nohighlight">\(f:\Sigma\rightarrow\Sigma\)</span> を表す行列 <span class="math notranslate nohighlight">\(M\)</span> は、以下を満たします。</p>
<div class="math notranslate nohighlight">
\[
M \vert a \rangle = \vert f(a)\rangle
\]</div>
<p>すべての <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> に対して上記を満たします。このような行列は常に存在し、一意です。</p>
<p>たとえば、上記の関数 <span class="math notranslate nohighlight">\(f_1,\ldots,f_4\)</span> に対応する行列 <span class="math notranslate nohighlight">\(M_1,\ldots,M_4\)</span> は次のとおりです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \rule[-6mm]{0mm}{14.5mm}
  M_1 =
  \begin{pmatrix}
    \class{_m00}{1} &amp; \class{_m10}{1}\\
    \class{_m01}{0} &amp; \class{_m11}{0}
  \end{pmatrix},
  \hspace{4mm}
  M_2 =
  \begin{pmatrix}
    \class{_m00}{1} &amp; \class{_m10}{0}\\
    \class{_m01}{0} &amp; \class{_m11}{1}
  \end{pmatrix},
  \hspace{4mm}
  M_3 =
  \begin{pmatrix}
    \class{_m00}{0} &amp; \class{_m10}{1}\\
    \class{_m01}{1} &amp; \class{_m11}{0}
  \end{pmatrix},
  \hspace{4mm}
  \text{and}
  \hspace{4mm}
  M_4 =
  \begin{pmatrix}
    \class{_m00}{0} &amp; \class{_m10}{0}\\
    \class{_m01}{1} &amp; \class{_m11}{1}
  \end{pmatrix}.
\end{split}\]</div>
<p>決定論的操作を表す行列は、常に各列に 1 つの <span class="math notranslate nohighlight">\(1\)</span> を持ち、他のすべての要素は <span class="math notranslate nohighlight">\(0\)</span> です。</p>
<p>これらの形式やその他の形式の行列を表す便利な方法は、前述の列ベクトルの表記法に類似した行ベクトルの表記法を使用することです。 <span class="math notranslate nohighlight">\(\langle a \vert\)</span> は、各 <span class="math notranslate nohighlight">\(a\in\Sigma\)</span> について、<span class="math notranslate nohighlight">\(a\)</span> に対応する要素が <span class="math notranslate nohighlight">\(1\)</span> で、他のすべての要素がゼロとなる <em>行</em> ベクトルを表します。このベクトルは「ブラ <span class="math notranslate nohighlight">\(a\)</span> 」と読みます。</p>
<p>たとえば、<span class="math notranslate nohighlight">\(\Sigma = {0,1}\)</span> の場合、以下のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \langle 0 \vert = \begin{pmatrix}
    1 &amp; 0
  \end{pmatrix}
  \quad\text{と}\quad
  \langle 1 \vert = \begin{pmatrix}
    0 &amp; 1
  \end{pmatrix}.
\]</div>
<p>古典的な状態集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> の任意の選択に対して、行ベクトルと列ベクトルを行列として表示し、行列乗算 <span class="math notranslate nohighlight">\(\vert b\rangle \langle a\vert\)</span> を実行すると、 <span class="math notranslate nohighlight">\((b,a)\)</span> のペアに対応する要素に <span class="math notranslate nohighlight">\(1\)</span> を含む正方行列が得られます。つまり、要素の行は <span class="math notranslate nohighlight">\(b\)</span> に対応し、列は <span class="math notranslate nohighlight">\(a\)</span> に対応し、他のすべての要素は <span class="math notranslate nohighlight">\(0\)</span> に対応します。例えば、以下のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \vert 0 \rangle \langle 1 \vert = \begin{pmatrix}
    0 &amp; 1 \\
    0 &amp; 0
  \end{pmatrix}.
\end{split}\]</div>
<p>この表記法を使用すると、任意の関数 <span class="math notranslate nohighlight">\(f:\Sigma\rightarrow\Sigma\)</span> に対して、関数 <span class="math notranslate nohighlight">\(f\)</span> に対応する行列 <span class="math notranslate nohighlight">\(M\)</span> を次のように表すことができます。</p>
<div class="math notranslate nohighlight">
\[
  M = \sum_{a\in\Sigma} \vert f(a) \rangle \langle a \vert.
\]</div>
<p>ここで、再びベクトルを行列として考えますが、今度は乗算 <span class="math notranslate nohighlight">\(\langle a \vert \vert b \rangle\)</span> を考えると、<span class="math notranslate nohighlight">\(1\times 1\)</span> 行列が得られ、これはスカラー（すなわち数）として考えることができます 。整理して、この積を <span class="math notranslate nohighlight">\(\langle a \vert \vert b \rangle\)</span> ではなく <span class="math notranslate nohighlight">\(\langle a \vert b\rangle\)</span> と書きます。この積は次の簡単な式を満たします。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \langle a \vert b \rangle
  = \begin{cases}
    1 &amp; a = b\\
    0 &amp; a \not= b.
  \end{cases}
\end{split}\]</div>
<p>この振る舞いから、行列の乗算が結合的で線形であるという事実とともに、次を得ます。</p>
<div class="math notranslate nohighlight">
\[
  M \vert b \rangle = 
  \Biggl(
  \sum_{a\in\Sigma} \vert f(a) \rangle \langle a \vert
  \Biggr)
  \vert b\rangle
  = \sum_{a\in\Sigma} \vert f(a) \rangle \langle a \vert b \rangle
  = \vert f(b)\rangle,
\]</div>
<p><span class="math notranslate nohighlight">\(b\in\Sigma\)</span> ごとに、これが <span class="math notranslate nohighlight">\(M\)</span> に要求されます。</p>
<p>後に、授業 3 で詳しく説明するように、<span class="math notranslate nohighlight">\(\langle a \vert b \rangle\)</span> は、ベクトル <span class="math notranslate nohighlight">\(\vert a\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert b\rangle\)</span> の間の <em>内積</em> と見なすこともできます。内積は量子情報において非常に重要ですが、必要になるまで議論しません。</p>
<p>この時点で、「ブラ」と 「ケット」 という名前が明らかかもしれません: 「ブラ」 <span class="math notranslate nohighlight">\(\langle a\vert\)</span> を 「ケット」 <span class="math notranslate nohighlight">\(\vert b\rangle\)</span> と一緒に置くと、「ブラケット」 <span class="math notranslate nohighlight">\(\langle a  \vert b\rangle\)</span> になります。この表記法と用語は <a class="reference internal" href="#gloss:dirac"><span class="xref myst">ポール・ディラック</span></a> によるものであり、この理由から <em>ディラック記法</em> として知られています。</p>
</section>
<section id="id8">
<h4>確率演算と確率行列<a class="headerlink" href="#id8" title="Link to this heading">#</a></h4>
<p>決定論的演算に加えて、 <em>確率論的演算</em> があります。</p>
<p>たとえば、ビットの古典的な状態が <span class="math notranslate nohighlight">\(0\)</span> の場合、そのままで、ビットの古典的な状態が <span class="math notranslate nohighlight">\(1\)</span> の場合、 <span class="math notranslate nohighlight">\(1/2\)</span> の確率で <span class="math notranslate nohighlight">\(0\)</span> に反転されるビットの演算を考えてみましょう。 この演算は次の行列で表されます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
    1 &amp; \frac{1}{2}\\[1mm]
    0 &amp; \frac{1}{2}
  \end{pmatrix}.
\end{split}\]</div>
<p>標準基底ベクトルを乗算することで、この行列が正しいことを確認できます。</p>
<p>古典状態の集合の任意の選択において、すべての確率演算の集合を、以下の 2 つの特性を満たす行列である <a class="reference internal" href="#gloss:altstochastic"><span class="xref myst">確率</span></a> 行列によって表される数学用語で説明できます。</p>
<ol class="arabic simple">
<li><p>すべての要素は非負の実数です。</p></li>
<li><p>すべての列の要素の合計は <span class="math notranslate nohighlight">\(1\)</span></p></li>
</ol>
<p>同様に、確率行列は、すべての列が確率ベクトルを形成する行列です。</p>
<p>上記の例のように、操作中にランダム性が何らかの形で使用または導入される可能性があるものとして、直感的なレベルで確率的演算を考えることができます。確率演算の確率行列の記述に関して、各列は、その列に対応する古典的な状態入力が与えられた場合に生成される確率状態のベクトル表現と見なすことができます。</p>
<p>また、確率行列は、常に確率ベクトルを確率ベクトルにマップする行列であると考えることができます。つまり、確率行列は常に確率ベクトルを確率ベクトルにマッピングするものであり、確率ベクトルを確率ベクトルにマッピングする行列は常に確率行列でなければなりません。</p>
<p>最後に、別の考え方として、確率的演算が決定論的演算のランダムな選択であるといえます。たとえば、上記の例の演算は、恒等関数または定数 0 の関数のいずれかを、それぞれ確率 <span class="math notranslate nohighlight">\(1/2\)</span> で適用すると考えることができます。これは次の式と一致します。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
    1 &amp; \frac{1}{2}\\[1mm]
    0 &amp; \frac{1}{2}
  \end{pmatrix}
  = \frac{1}{2}
  \begin{pmatrix}
    1 &amp; 0\\[1mm]
    0 &amp; 1
  \end{pmatrix}
  + \frac{1}{2}
  \begin{pmatrix}
    1 &amp; 1\\[1mm]
    0 &amp; 0
  \end{pmatrix}.
\end{split}\]</div>
<p>このような表現は、古典的な状態の集合と、その古典的な状態の集合で識別される行と列を持つ任意の確率行列の任意の選択に対して常に可能です。</p>
</section>
<section id="id9">
<h4>確率演算の合成<a class="headerlink" href="#id9" title="Link to this heading">#</a></h4>
<p><span class="math notranslate nohighlight">\(\mathsf{X}\)</span> が古典的な状態の集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> を持つシステムであり、<span class="math notranslate nohighlight">\(M_1,\ldots,M_n\)</span> がシステム <span class="math notranslate nohighlight">\(\mathsf{X}\)</span> 上の確率的操作を表す確率行列であるとします。</p>
<p>最初の操作 <span class="math notranslate nohighlight">\(M_1\)</span> が確率ベクトル <span class="math notranslate nohighlight">\(u\)</span> で表される確率的状態に適用される場合、結果の確率的状態はベクトル <span class="math notranslate nohighlight">\(M_1 u\)</span> で表されます。次に、2 番目の確率的演算 <span class="math notranslate nohighlight">\(M_2\)</span> をこの新しい確率ベクトルに適用すると以下の確率ベクトルを得ます。</p>
<div class="math notranslate nohighlight">
\[
  M_2 (M_1 u) = (M_2 M_1) u.
\]</div>
<p>この等式は、行列の乗算 (特殊なケースとして行列とベクトルの乗算を含む) が <a class="reference internal" href="#gloss:associative"><span class="xref myst">結合的な</span></a> 演算であるという事実から得られます。したがって、最初に <span class="math notranslate nohighlight">\(M_1\)</span> を適用し、次に <span class="math notranslate nohighlight">\(M_2\)</span> を適用する 1 番目と 2 番目の確率演算を <a class="reference internal" href="#gloss:composing"><span class="xref myst">合成</span></a> することによって得られる確率演算は、行列 <span class="math notranslate nohighlight">\(M_2 M_1\)</span> で表され、これは必然的に確率的です。</p>
<p>より一般的には、行列 <span class="math notranslate nohighlight">\(M_1,\ldots,M_n\)</span> で表される確率演算をこの順序で合成します。つまり、<span class="math notranslate nohighlight">\(M_1\)</span> が最初に適用され、<span class="math notranslate nohighlight">\(M_2\)</span> が 2 番目に適用され、<span class="math notranslate nohighlight">\(M_n\)</span> が最後に適用されることを以下の行列で表します。</p>
<div class="math notranslate nohighlight">
\[
  M_n \,\cdots\, M_1.
\]</div>
<p>ここでは順序が重要であることに注意してください。行列の乗算は合成されますが、一般に <a class="reference internal" href="#gloss:commutative"><span class="xref myst">可換</span></a> 演算ではありません。</p>
<p>たとえば、</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  M_1 = 
  \begin{pmatrix}
    1 &amp; 1\\[1mm]
    0 &amp; 0
  \end{pmatrix}
  \quad\text{と}\quad
  M_2 =
  \begin{pmatrix}
    0 &amp; 1\\[1mm]
    1 &amp; 0
  \end{pmatrix},
\end{split}\]</div>
<p>の場合、以下のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  M_2 M_1 = 
  \begin{pmatrix}
    0 &amp; 0 \\[1mm]
    1 &amp; 1
  \end{pmatrix}
  \quad\text{と}\quad
  M_1 M_2 =
  \begin{pmatrix}
    1 &amp; 1\\[1mm]
    0 &amp; 0
  \end{pmatrix}.
\end{split}\]</div>
<p>つまり、確率的演算が合成される順序が重要です。合成結合の操作が適用される順序を変更すると、結果の操作が変更される可能性があります。</p>
</section>
</section>
</section>
<section id="id10">
<h2>2. 量子情報<a id="single-systems-quantum"></a><a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>ここで、検討中のシステムの状態 （この場合は <em>量子状態</em> ）を表すベクトルの種類について、別の選択を行います。この前の章と同様に、古典的な状態の有限で空でない集合を持つシステムに関係し、前章で導入された表記法の多くを利用します。</p>
<section id="id11">
<h3>2.1 量子状態ベクトル<a id="single-systems-quantum-states"></a><a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>システムの<em>量子状態</em>は、確率的状態と同様に列ベクトルで表されます。前述のように、ベクトルのインデックスがシステムの古典的な状態にラベルを付けます。量子状態を表すベクトルは、次の 2 つの特性によって特徴付けられます。</p>
<ol class="arabic simple">
<li><p>量子状態ベクトルの要素は <em>複素数</em> です。</p></li>
<li><p>量子状態ベクトルの要素の <em>絶対値の二乗</em> の合計は <span class="math notranslate nohighlight">\(1\)</span> に等しくなければなりません。</p></li>
</ol>
<p>したがって、確率論的な場合とは対照的に、量子状態を表すベクトルは非負の実数の要素を持つ必要はなく、 <span class="math notranslate nohighlight">\(1\)</span> に等しくなければならないのは、(要素の合計ではなく) 要素の絶対値の 2 乗の合計です。この変化は単純ですが、量子情報と古典情報の間にすべての違いが生じます。量子コンピューターによるスピードアップや通信プロトコルの改善は、最終的にはこの単純な数学的変化に由来します。</p>
<p>列ベクトルの <em>ユークリッド ノルム</em></p>
<div class="math notranslate nohighlight">
\[\begin{split}
  v = \begin{pmatrix}
    \alpha_1\\
    \vdots\\
    \alpha_n
  \end{pmatrix}
\end{split}\]</div>
<p>は次のように示され、定義されます。</p>
<div class="math notranslate nohighlight">
\[
  \| v \| = \sqrt{\sum_{k=1}^n |\alpha_k|^2}.
\]</div>
<p>したがって、量子状態ベクトルの絶対値の二乗の合計が <span class="math notranslate nohighlight">\(1\)</span> に等しいという条件は、 <span class="math notranslate nohighlight">\(1\)</span> に等しいユークリッド ノルムを持つベクトルと等価です。つまり、量子状態ベクトルは、ユークリッド ノルムに関する <em>単位ベクトル</em> です。</p>
<section id="id12">
<h4>量子ビット状態の例<a class="headerlink" href="#id12" title="Link to this heading">#</a></h4>
<p><em>量子ビット</em> という用語は、古典的な状態の集合が  <span class="math notranslate nohighlight">\(\{0,1\}\)</span> である量子システムを指します。つまり、量子ビットは実際にはほんの少しですが、この名前を使用することで、私たちはこのビットが量子状態になる可能性があることを明示的に認識しています。</p>
<p>以下は、量子ビットの量子状態の例です。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
    1\\[2mm]
    0
  \end{pmatrix}
  = \vert 0\rangle
  \quad\text{と}\quad
  \begin{pmatrix}
    0\\[2mm]
    1
  \end{pmatrix}
  = \vert 1\rangle,
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}  
  \begin{pmatrix}
    \frac{1}{\sqrt{2}}\\[2mm]
    \frac{1}{\sqrt{2}}
  \end{pmatrix}
  = \frac{1}{\sqrt{2}}\,\vert 0\rangle + \frac{1}{\sqrt{2}}\,\vert 1\rangle,
  \tag{1}
\end{split}\]</div>
<p>と
$<span class="math notranslate nohighlight">\(
  \begin{pmatrix}
    \frac{1+2i}{3}\\[2mm]
    -\frac{2}{3}
  \end{pmatrix}
  = \frac{1+2i}{3}\,\vert 0\rangle - \frac{2}{3}\,\vert 1\rangle.
\)</span>$</p>
<p>最初の 2 つの例、 <span class="math notranslate nohighlight">\(\vert 0\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert 1\rangle\)</span> は、標準基底の要素となる量子状態ベクトルであることを示しています：これらの要素は複素数で（この場合の数値の虚数部分はたまたま <span class="math notranslate nohighlight">\(0\)</span> です）、要素の絶対値の二乗の合計を計算すると、</p>
<div class="math notranslate nohighlight">
\[
  \vert 1\vert^2 + \vert 0\vert^2 = 1
  \quad\text{と}\quad
  \vert 0\vert^2 + \vert 1\vert^2 = 1,
\]</div>
<p>が要求されます。古典的な設定と同様に、量子状態ベクトル <span class="math notranslate nohighlight">\(\vert 0\rangle\)</span> および <span class="math notranslate nohighlight">\(\vert 1\rangle\)</span> を、それぞれ古典的な状態 <span class="math notranslate nohighlight">\(0\)</span> または <span class="math notranslate nohighlight">\(1\)</span> にある量子ビットに確実に関連付けます。</p>
<p>他の 2 つの例では、複素数の要素があり、要素の絶対値の 2 乗の和を求めると、次の結果が得られます。</p>
<div class="math notranslate nohighlight">
\[
  \biggl\vert\frac{1}{\sqrt{2}}\biggr\vert^2 +
  \biggl\vert\frac{1}{\sqrt{2}}\biggr\vert^2 = \frac{1}{2} + \frac{1}{2} = 1
\]</div>
<p>と</p>
<div class="math notranslate nohighlight">
\[
  \biggl\vert \frac{1+2i}{3} \biggr\vert^2 +
  \biggl\vert -\frac{2}{3} \biggr\vert^2 = \frac{5}{9} + \frac{4}{9} = 1.
\]</div>
<p>したがって、これらは正しく量子状態ベクトルです。これらは状態 <span class="math notranslate nohighlight">\(\vert 0 \rangle\)</span> と <span class="math notranslate nohighlight">\(\vert 1 \rangle\)</span> の線形結合であることに注意してください。これらの状態は <span class="math notranslate nohighlight">\(0\)</span> 状態と <span class="math notranslate nohighlight">\(1\)</span> 状態の <em>重ね合わせ</em> であるとよく言います。量子状態のコンテキスト内では、「重ね合わせ」と「線形結合」は本質的に同義です。</p>
<p>上記の量子ビット状態ベクトルの <span class="math notranslate nohighlight">\((1)\)</span> の例は非常によく見られます — これは <em>プラス状態</em> と呼ばれ、次のように表されます。</p>
<div class="math notranslate nohighlight">
\[
  \vert + \rangle = \frac{1}{\sqrt{2}} \vert 0\rangle + \frac{1}{\sqrt{2}} \vert 1\rangle.
\]</div>
<p>また、以下の表記もあり、</p>
<div class="math notranslate nohighlight">
\[
  \vert - \rangle = \frac{1}{\sqrt{2}} \vert 0\rangle - \frac{1}{\sqrt{2}} \vert 1\rangle
\]</div>
<p>この2 番目の要素が正ではなく負である関連する量子状態ベクトルを <em>マイナス状態</em> と呼びます。古典的な状態を参照するもの以外の記号がケット内に現れるこの種の表記法は一般的です — ケット内で任意の名前を使用して、ベクトルに名前を付けることができます。</p>
<p>実際、標準基底ベクトルであるとは限らない任意のベクトルを参照するために、 <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> のような表記、または <span class="math notranslate nohighlight">\(\psi\)</span> の代わりに他の名前を使用することは非常に一般的です:  <span class="math notranslate nohighlight">\(\psi \)</span> は単にベクトルの名前ですが、ベクトルであることを強調する ケット内に置かれます。</p>
<p>ベクトル <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> があり、そのインデックスが古典的な状態集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> に対応し、<span class="math notranslate nohighlight">\(a\in\Sigma\)</span> がこの古典的な状態の集合の要素である場合、（行列） 積 <span class="math notranslate nohighlight">\(\langle a\vert \vert \psi\rangle\)</span> は、インデックスが <span class="math notranslate nohighlight">\(a\)</span> に対応するベクトル <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> の要素に等しいです。 <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> が標準基底ベクトルであるときに行ったように、読みやすさのために <span class="math notranslate nohighlight">\(\langle a\vert \vert \psi\rangle\)</span> ではなく、 <span class="math notranslate nohighlight">\(\langle a \vert \psi \rangle\)</span> と書きます。</p>
<p>たとえば、<span class="math notranslate nohighlight">\(\Sigma = {0,1}\)</span> と</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\vert \psi \rangle =
\frac{1+2i}{3} \vert 0\rangle - \frac{2}{3} \vert 1\rangle
= \begin{pmatrix}
    \frac{1+2i}{3}\\[2mm]
    -\frac{2}{3}
  \end{pmatrix},
  \tag{2}
\end{split}\]</div>
<p>については以下のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \langle 0 \vert \psi \rangle = \frac{1+2i}{3}
  \quad\text{と}\quad
  \langle 1 \vert \psi \rangle = -\frac{2}{3}.
\]</div>
<p>この表記法を使うには、<span class="math notranslate nohighlight">\(\langle \psi \vert\)</span> は、列ベクトル <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> の <em>共役転置</em> を取ることによって得られる行ベクトルを指すことを理解する必要があります。（列ベクトルから行ベクトルへの転置に加えて）各要素はその複素共役に置き換えられます。</p>
<p>たとえば、 <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> が <span class="math notranslate nohighlight">\((2)\)</span> で定義されたベクトルである場合、以下のようになります。</p>
<div class="math notranslate nohighlight">
\[
\langle\psi\vert = \frac{1-2i}{3} \langle 0\vert - \frac{2}{3} \langle 1\vert
= \begin{pmatrix}
    \frac{1-2i}{3} &amp;amp;
    -\frac{2}{3}
  \end{pmatrix}.
\]</div>
<p>転置に加えて複素共役を使用する理由は、授業 3 で <em>内積</em> について議論すると、より明確になります。</p>
</section>
<section id="id13">
<h4>他の系の量子状態<a class="headerlink" href="#id13" title="Link to this heading">#</a></h4>
<p>任意の古典的な状態の集合を持つ系の量子状態を考えることができます。</p>
<p>たとえば、扇風機スイッチの量子状態ベクトルは次のとおりです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{pmatrix}
    \frac{1}{2}\\[1mm]
    0 \\[1mm]
    -\frac{i}{2}\\[1mm]
    \frac{1}{\sqrt{2}}
  \end{pmatrix}
  =
  \frac{1}{2} \vert\mathrm{high}\rangle
  - \frac{i}{2} \vert\mathrm{low}\rangle
  + \frac{1}{\sqrt{2}} \vert\mathrm{off}\rangle.
\end{split}\]</div>
<p>ここでの前提は、従来の状態が <em>高</em> 、 <em>中</em> 、 <em>低</em> 、 <em>オフ</em> の順序になっていることです。扇風機のスイッチの量子状態を考慮したい特別な理由はないかもしれませんが、原理的には可能です。</p>
<p>別の例を次に示します。今回は、古典的な状態が  <span class="math notranslate nohighlight">\(0,1,\ldots,9\)</span> である量子 10 進数です。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \frac{1}{\sqrt{385}}
  \begin{pmatrix}
    1\\
    2\\
    3\\
    4\\
    5\\
    6\\
    7\\
    8\\
    9\\
    10
  \end{pmatrix}
  =
  \frac{1}{\sqrt{385}}\sum_{k = 0}^9 (k+1) \vert k \rangle.
\end{split}\]</div>
<p>この例は、ディラック記法を使用して状態ベクトルを記述する便利さを示しています。この特定の例では、列ベクトルの表現は面倒であり、古典的な状態がはるかに多い場合は使用できなくなります。対照的に、ディラック記法は、大きくて複雑なベクトルの正確な記述をコンパクトな形式でサポートします。</p>
<p>ディラック記法では、ベクトルのさまざまな側面が <em>不確定な</em> （未知または未確立を意味する）ベクトルの表現も可能です。たとえば、任意の古典的な状態集合 <span class="math notranslate nohighlight">\(\Sigma\)</span> に対して、量子状態ベクトルを考えることができます。</p>
<div class="math notranslate nohighlight">
\[
  \frac{1}{\sqrt{|\Sigma|}} \sum_{a\in\Sigma} \vert a \rangle,
\]</div>
<p>これは、 <span class="math notranslate nohighlight">\(\Sigma\)</span> の古典的な状態に対する一様な重ね合わせです。（ここで、 <span class="math notranslate nohighlight">\(\vert\Sigma\vert\)</span> という表記は、 <span class="math notranslate nohighlight">\(\Sigma\)</span> の要素数を表します。）</p>
<p>この後の授業では、列ベクトルの使用が非現実的または不可能な量子状態ベクトルのより複雑な表現に遭遇します。実際、要素を明示的に表示して調べることが役立つ場合がある少数の要素を持つベクトル（多くの場合、例にあるようなもの）を除いて、状態ベクトルの列ベクトル表現はほとんど行いません。</p>
<p>ディラック記法を使用して状態ベクトルを表現する方が一般的に便利である理由がもう 1 つあります。それは、古典的な状態の順序付け（または、同等に、古典的な状態とベクトル インデックス間の対応）を明示的に指定する必要性を軽減するためです。たとえば、次のような古典的な状態セット  <span class="math notranslate nohighlight">\(\{\clubsuit,\diamondsuit,\heartsuit,\spadesuit\}\)</span> を持つシステムの量子状態ベクトル</p>
<div class="math notranslate nohighlight">
\[
    \frac{1}{2} \vert\clubsuit\rangle
  + \frac{i}{2} \vert\diamondsuit\rangle
  - \frac{1}{2} \vert\heartsuit\rangle
  - \frac{i}{2} \vert\spadesuit\rangle,
\]</div>
<p>はこの式によって明確に記述されており、式を理解するためにこの古典的な状態の集合の順序を選択または指定する必要は実際にはありません。この場合、標準のカードセットの順序を単に指定することは難しくありません。たとえば、 <span class="math notranslate nohighlight">\(\clubsuit\)</span> 、 <span class="math notranslate nohighlight">\(\diamondsuit\)</span> 、 <span class="math notranslate nohighlight">\(\heartsuit\)</span> 、 <span class="math notranslate nohighlight">\(\spadesuit\)</span>  のように指定します。この特定の順序を選択すると、上記の量子状態ベクトルは以下の列ベクトルで表されます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
 \frac{1}{2}\\[2mm]
 \frac{i}{2}\\[2mm]
 -\frac{1}{2}\\[2mm]
 -\frac{i}{2}
\end{pmatrix}.
\end{split}\]</div>
<p>ただし、一般的には、古典的な状態の集合がどのように順序付けられているかという問題を無視し、量子状態ベクトルが古典的な状態によって直接インデックス付けされていると見なすのが便利です。</p>
</section>
</section>
<section id="id14">
<h3>2.2 量子状態の測定 <a id="single-systems-quantum-measure"></a><a class="headerlink" href="#id14" title="Link to this heading">#</a></h3>
<p>次に、量子状態を <em>測定</em> するとどうなるか、 <em>標準基底測定</em> と呼ばれるシンプルな測定に焦点を当てて考えてみましょう。（後で測定のより一般的な概念を説明します。）</p>
<p>確率論的設定と同様に、量子状態のシステムが測定される場合、測定を実行する観測者は量子状態ベクトルではなく、何らかの古典的な状態を確認します。この意味で、測定は量子情報と古典情報の間のインターフェースとして機能し、それを介して古典情報が量子状態から抽出されます。</p>
<p>ルールは単純です。量子状態が測定される場合、システムの各古典的状態は、その古典的状態に対応する量子状態ベクトルの要素の <em>絶対値の 2 乗</em> に等しい確率で得られます。これは、量子力学の <em>ボルン規則</em> として知られています。このルールは、量子状態ベクトルの要素の絶対値の 2 乗の合計が 1 になるという要件と一致していることに注意してください。これは、さまざまな古典的な状態測定結果の確率の合計が <span class="math notranslate nohighlight">\(1\)</span> になることを意味するためです。</p>
<p>たとえば、プラス状態を測定すると</p>
<div class="math notranslate nohighlight">
\[
  \vert + \rangle =
  \frac{1}{\sqrt{2}} \vert 0 \rangle
  + \frac{1}{\sqrt{2}} \vert 1 \rangle
\]</div>
<p><span class="math notranslate nohighlight">\(0\)</span> と <span class="math notranslate nohighlight">\(1\)</span> の 2 つの結果が得られ、確率は次のようになります。</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}(\text{outcome is 0})
  = \bigl\vert \langle 0 \vert + \rangle \bigr\vert^2
  = \biggl\vert \frac{1}{\sqrt{2}} \biggr\vert^2
  = \frac{1}{2}
\]</div>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}(\text{outcome is 1})
  = \bigl\vert \langle 1 \vert + \rangle \bigr\vert^2
  = \biggl\vert \frac{1}{\sqrt{2}} \biggr\vert^2
  = \frac{1}{2}
\]</div>
<p>興味深いことに、マイナス状態を測定すると</p>
<div class="math notranslate nohighlight">
\[
  \vert - \rangle =
  \frac{1}{\sqrt{2}} \vert 0 \rangle
  - \frac{1}{\sqrt{2}} \vert 1 \rangle
\]</div>
<p>2 つの結果の確率はまったく同じになります。</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}(\text{outcome is 0})
  = \bigl\vert \langle 0 \vert - \rangle \bigr\vert^2
  = \biggl\vert \frac{1}{\sqrt{2}} \biggr\vert^2
  = \frac{1}{2}
\]</div>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}(\text{outcome is 1})
  = \bigl\vert \langle 1 \vert - \rangle \bigr\vert^2
  = \biggl\vert -\frac{1}{\sqrt{2}} \biggr\vert^2
  = \frac{1}{2}
\]</div>
<p>これは、標準基底測定に関する限り、プラスとマイナスの状態がまったく同じであることを示唆しています。では、なぜ区別する必要があるのでしょうか。この問題については、次のセクション 2.3 で説明します。</p>
<p>最後の例として、以下の状態の測定</p>
<div class="math notranslate nohighlight">
\[
  \vert \psi \rangle = \frac{1+2i}{3} \vert 0\rangle - \frac{2}{3} \vert 1\rangle
\]</div>
<p>では以下の確率が与えられます。</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}(\text{outcome is 0})
  = \bigl\vert \langle 0 \vert \psi \rangle \bigr\vert^2
  = \biggl\vert \frac{1+2i}{3} \biggr\vert^2
  = \frac{5}{9},
\]</div>
<p>と以下です。</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{Pr}(\text{outcome is 1})
  = \bigl\vert \langle 1 \vert \psi \rangle \bigr\vert^2
  = \biggl\vert -\frac{2}{3} \biggr\vert^2
  = \frac{4}{9}.
\]</div>
<p>もちろん、量子状態 <span class="math notranslate nohighlight">\(\vert 0\rangle\)</span> を測定すると確実に古典的状態 <span class="math notranslate nohighlight">\(0\)</span> が得られ、同様に量子状態  <span class="math notranslate nohighlight">\(\vert 1\rangle\)</span> を測定すると確実に古典的状態 <span class="math notranslate nohighlight">\(1\)</span>  が得られます。これは、以前に示唆されたように、システムが対応する古典的な状態にあるこれらの量子状態の識別と一致  <em>しています。</em></p>
</section>
<section id="id15">
<h3>2.3 ユニタリー演算 <a id="single-systems-unitary"></a><a class="headerlink" href="#id15" title="Link to this heading">#</a></h3>
<p>これまでのところ、量子情報が古典的な情報と根本的に異なる理由は明らかではないかもしれません。つまり、量子状態が測定されると、各古典的状態を取得する確率は、対応するベクトルの要素の絶対値の 2 乗で与えられます。では、これらの確率を単純に確率ベクトルに記録してみませんか?</p>
<p>その答えは、少なくとも部分的には、量子状態に対して実行できる一連の許容 <em>操作</em> が、従来の情報に対するものとは異なるということです。確率論的設定と同様に、量子状態の操作は線形マッピングですが、古典的なケースのように確率行列で表されるのではなく、量子状態ベクトルの操作は <em>ユニタリー</em> 行列で表されます。</p>
<p>複素数の要素を持つ正方行列 <span class="math notranslate nohighlight">\(U\)</span> が、以下の方程式を満たす場合、ユニタリーです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{aligned}
    U U^{\dagger} &amp;= \class{identity-matrix}{\mathbb{1}} \\
    U^{\class{conjugate-transpose}{\dagger}} U &amp;= \class{identity-matrix}{\mathbb{1}}.
  \end{aligned}
\end{split}\]</div>
<p>ここで、 <span class="math notranslate nohighlight">\(\mathbb{1}\)</span> は恒等行列、 <span class="math notranslate nohighlight">\(U^{\dagger}\)</span> は <span class="math notranslate nohighlight">\(U\)</span> の <em>共役転置</em> 、つまり <span class="math notranslate nohighlight">\(U\)</span> を転置し、各要素の複素共役を取ることによって得られる行列を意味します。<br />
$<span class="math notranslate nohighlight">\(
  U^{\dagger} = \overline{U^T}
\)</span><span class="math notranslate nohighlight">\(
上記の等式のいずれかが真である場合、もう一方も真でなければなりません。両方の等号は、 \)</span>U^{\dagger}<span class="math notranslate nohighlight">\( が \)</span>U$ の逆行列であることと同等です。</p>
<div class="math notranslate nohighlight">
\[
  U^{-1} = U^{\dagger}.
\]</div>
<p>（警告: <span class="math notranslate nohighlight">\(M\)</span> が正方行列でない場合、 <span class="math notranslate nohighlight">\(M^{\dagger} M = \mathbb{1}\)</span> および <span class="math notranslate nohighlight">\(MM^{\dagger} \not= \mathbb{1}\)</span> である可能性があります。たとえば、上記の最初の方程式の 2 つの等式の等価性は、正方行列の場合にのみ当てはまります。）</p>
<p><span class="math notranslate nohighlight">\(U\)</span> がユニタリーであるという条件は、 どのベクトルに<span class="math notranslate nohighlight">\(U\)</span> を掛けても、ユークリッド ノルムが変わらないという条件と同じです。つまり、 <span class="math notranslate nohighlight">\(n\times n\)</span> 行列 <span class="math notranslate nohighlight">\(U\)</span> がユニタリーになるのは、すべての <span class="math notranslate nohighlight">\(n\)</span> 次元の列ベクトル <span class="math notranslate nohighlight">\(\vert \psi \rangle\)</span> に対して複素数要素が指定され、
<span class="math notranslate nohighlight">\(\\| U \vert \psi \rangle \\| = \\|\vert \psi \rangle \\|\)</span>
の場合だけです。 したがって、すべての量子状態ベクトルの集合は、<span class="math notranslate nohighlight">\(1\)</span> に等しいユークリッド ノルムを持つベクトルの集合と同じであるため、ユニタリー行列を量子状態ベクトルに掛けると、別の量子状態ベクトルが得られます。</p>
<p>実際、ユニタリー行列は、まさに量子状態ベクトルを他の量子状態ベクトルに変換する線形写像の集合です。ここで、確率ベクトルを確率ベクトルに常に変換するものである確率行列に演算が関連付けられている、古典的な確率論的ケースに類似していることに注意してください。</p>
<section id="id16">
<h4>量子ビットへのユニタリー演算の重要な例<a class="headerlink" href="#id16" title="Link to this heading">#</a></h4>
<p>以下のリストで、量子ビットに対するいくつかの重要なユニタリー演算について説明します。</p>
<ol class="arabic">
<li><p><em>パウリ演算子</em> 。4 つのパウリ行列は次のとおりです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
     \mathbb{1} =
     \begin{pmatrix}
       1 &amp; 0\\
       0 &amp; 1
     \end{pmatrix},
     \quad
     \sigma_x =
     \begin{pmatrix}
       0 &amp; 1\\
       1 &amp; 0
     \end{pmatrix},
     \quad
     \sigma_y =
     \begin{pmatrix}
       0 &amp; -i\\
       i &amp; 0
     \end{pmatrix},
     \quad
     \sigma_z =
     \begin{pmatrix}
       1 &amp; 0\\
       0 &amp; -1
     \end{pmatrix}.
   \end{split}\]</div>
<p>私たちがよく使用する一般的な表記法は、 <span class="math notranslate nohighlight">\(X = \sigma_x\)</span> 、 <span class="math notranslate nohighlight">\(Y = \sigma_y\)</span> 、および <span class="math notranslate nohighlight">\(Z = \sigma_z\)</span> ですが、文字 <span class="math notranslate nohighlight">\(X\)</span>、<span class="math notranslate nohighlight">\(Y\)</span>、および <span class="math notranslate nohighlight">\(Z\)</span> は、他の目的にもよく使用されるので注意してください。 <span class="math notranslate nohighlight">\(\sigma_x\)</span> (または <span class="math notranslate nohighlight">\(X\)</span>) 演算は、ビットに対してこの動作を誘発するため、 <em>ビット フリップ</em> または <em>NOT 演算</em> とも呼ばれます。</p>
<div class="math notranslate nohighlight">
\[
         \sigma_x \vert 0\rangle = \vert 1\rangle
         \quad \text{と} \quad
         \sigma_x \vert 1\rangle = \vert 0\rangle.
       \]</div>
<p><span class="math notranslate nohighlight">\(\sigma_z\)</span> (または <span class="math notranslate nohighlight">\(Z\)</span>) 演算は、次のような動作のため、 <em>位相反転</em> とも呼ばれます。</p>
<div class="math notranslate nohighlight">
\[
         \sigma_z \vert 0\rangle = \vert 0\rangle
         \quad \text{と} \quad
         \sigma_z \vert 1\rangle = - \vert 1\rangle.
       \]</div>
</li>
<li><p><em>アダマール演算</em> 。アダマール演算は、次の行列で表されます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
     H = \begin{pmatrix}
       \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
       \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
     \end{pmatrix}.
   \end{split}\]</div>
</li>
<li><p><em>位相演算</em> 。位相演算は、以下の行列によって記述され、</p>
<div class="math notranslate nohighlight">
\[\begin{split}
     P_{\theta} =
     \begin{pmatrix}
       1 &amp; 0\\
       0 &amp; e^{i\theta}
     \end{pmatrix}
   \end{split}\]</div>
<p>任意の実数 <span class="math notranslate nohighlight">\(\theta\)</span> に対して演算がなされます。以下の演算</p>
<div class="math notranslate nohighlight">
\[\begin{split}
     S = P_{\pi/2} =
     \begin{pmatrix}
       1 &amp; 0\\
       0 &amp; i
     \end{pmatrix}
     \quad\text{と}\quad
     T
     = P_{\pi/4} 
     =
     \begin{pmatrix}
       1 &amp; 0\\
       0 &amp; \frac{1 + i}{\sqrt{2}}
     \end{pmatrix}
   \end{split}\]</div>
<p>は特に重要な例です。他の例には、 <span class="math notranslate nohighlight">\(\mathbb{1} = P_0\)</span> や  <span class="math notranslate nohighlight">\(\sigma_z = P_{\pi}\)</span> などがあります。</p>
</li>
</ol>
<p>ここで定義したすべての行列はユニタリーであるため、単一量子ビットに対する量子演算を表します。</p>
<p>たとえば、<span class="math notranslate nohighlight">\(H\)</span> がユニタリーであることを確認する計算は次のとおりです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{aligned}
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}^{\dagger}
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  &amp; =
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}\\[2mm]
  &amp; = \begin{pmatrix}
    \frac{1}{2} + \frac{1}{2} &amp; \frac{1}{2} - \frac{1}{2}\\[2mm]
    \frac{1}{2} - \frac{1}{2} &amp; \frac{1}{2} + \frac{1}{2}
  \end{pmatrix}\\[2mm]
  &amp; =
  \begin{pmatrix}
    1 &amp; 0\\
    0 &amp; 1
  \end{pmatrix}.
  \end{aligned}
\end{split}\]</div>
<p>以下は、量子ビット状態ベクトルに対するアダマール演算の動作例です。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
   \begin{aligned}
  H \vert 0 \rangle &amp; = 
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  \begin{pmatrix}
    1\\[2mm]
    0
  \end{pmatrix}
  =
  \begin{pmatrix}
    \frac{1}{\sqrt{2}}\\[2mm]
    \frac{1}{\sqrt{2}}
  \end{pmatrix}
  = \vert + \rangle,\\[2mm]
  H \vert 1 \rangle
  &amp; =
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  \begin{pmatrix}
    0\\[2mm]
    1
  \end{pmatrix}
  =
  \begin{pmatrix}
    \frac{1}{\sqrt{2}}\\[2mm]
    -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  = \vert - \rangle,\\[2mm]
  H \vert + \rangle
  &amp; =
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  \begin{pmatrix}
    \frac{1}{\sqrt{2}}\\[2mm]
    \frac{1}{\sqrt{2}}
  \end{pmatrix}
  =
  \begin{pmatrix}
    1\\[2mm]
    0
  \end{pmatrix}
  = \vert 0 \rangle,\\[2mm]
  H \vert - \rangle
  &amp; =
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  \begin{pmatrix}
    \frac{1}{\sqrt{2}}\\[2mm]
    -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  =
  \begin{pmatrix}
    0\\[2mm]
    1
  \end{pmatrix}
  = \vert 1 \rangle
  \end{aligned}
\end{split}\]</div>
<p>と</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{aligned}
    H \biggl(\frac{1+2i}{3} \vert 0\rangle - \frac{2}{3} \vert 1\rangle\biggr)
    &amp; =
    \begin{pmatrix}
      \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
      \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
    \end{pmatrix}
    \begin{pmatrix}
      \frac{1+2i}{3}\\[2mm]
      -\frac{2}{3}
    \end{pmatrix}\\[2mm]
    &amp; =
    \begin{pmatrix}
      \frac{-1+2i}{3\sqrt{2}}\\[2mm]
      \frac{3+2i}{3\sqrt{2}}
    \end{pmatrix}\\[2mm]
    &amp; =
    \frac{-1+2i}{3\sqrt{2}} | 0 \rangle
    + \frac{3+2i}{3\sqrt{2}} | 1 \rangle
  \end{aligned}
\end{split}\]</div>
<p>この最後の例は重要ではありませんが、それ以外の例は以下のように、より簡潔に要約する価値があります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \begin{aligned}
    H \vert 0 \rangle &amp; = \vert + \rangle,\\[2mm]
    H \vert 1 \rangle &amp; = \vert - \rangle,\\[2mm]
    H \vert + \rangle &amp; = \vert 0 \rangle,\\[2mm]
    H \vert - \rangle &amp; = \vert 1 \rangle
  \end{aligned}
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(H\vert +\rangle = \vert 0\rangle\)</span> および <span class="math notranslate nohighlight">\(H\vert -\rangle = \vert 1\rangle\)</span> であるという事実をここでストップして考える価値があります。 <span class="math notranslate nohighlight">\(\vert +\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert -\rangle\)</span> の 2 つの量子状態のいずれかで量子ビットが準備されているが、どちらであるかがわからない状況を考えてみましょう。どちらかの状態を測定すると、もう一方と同じ出力分布が生成されます:  つまり<span class="math notranslate nohighlight">\(0\)</span> と <span class="math notranslate nohighlight">\(1\)</span> は両方とも等しい確率 <span class="math notranslate nohighlight">\(1/2\)</span> で表示されます。したがって、これでは、元々用意されていた2 つの状態 <span class="math notranslate nohighlight">\(\vert +\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert -\rangle\)</span> のどちらについての情報も提供されません。しかし、アダマール演算を適用して測定すると、元の状態が <span class="math notranslate nohighlight">\(\vert +\rangle\)</span> の場合は確実に結果 <span class="math notranslate nohighlight">\(0\)</span> が得られ、元の状態が <span class="math notranslate nohighlight">\(\vert -\rangle\)</span> の場合は結果 <span class="math notranslate nohighlight">\(1\)</span> が確実に得られます。 したがって、量子状態 <span class="math notranslate nohighlight">\(\vert +\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert -\rangle\)</span> は <em>完全</em> に区別できます。これは、量子状態ベクトルの複素数要素の符号の変更、またはより一般的には <em>位相</em> (伝統的に <em>偏角</em> とも呼ばれる) の変更が、その状態を大幅に変更できることを明らかにしています。</p>
<p>別の例を次に示します。今回は、プラス状態に対する <span class="math notranslate nohighlight">\(T\)</span> 操作の動作です。</p>
<div class="math notranslate nohighlight">
\[
  T \vert +\rangle 
  = T \biggl(\frac{1}{\sqrt{2}} \vert 0\rangle + \frac{1}{\sqrt{2}} \vert 1\rangle\biggr) 
  = \frac{1}{\sqrt{2}} T\vert 0\rangle + \frac{1}{\sqrt{2}} T\vert 1\rangle
  = \frac{1}{\sqrt{2}} \vert 0\rangle + \frac{1+i}{2} \vert 1\rangle
\]</div>
<p>ここで、同等の行列/ベクトル形式にわざわざ変換せず、代わりに式と一緒に行列乗算の線形性を使用したことに注意してください。</p>
<div class="math notranslate nohighlight">
\[
T \vert 0\rangle = \vert 0\rangle 
\quad\text{and}\quad
T \vert 1\rangle = \frac{1 + i}{\sqrt{2}} \vert 1\rangle.
\]</div>
<p>同様に、得られたばかりの量子状態ベクトルにアダマール演算を適用した結果を計算できます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
H\,  \biggl(\frac{1}{\sqrt{2}} \vert 0\rangle + \frac{1+i}{2} \vert 1\rangle\biggr)
&amp; = \frac{1}{\sqrt{2}} H \vert 0\rangle + \frac{1+i}{2} H \vert 1\rangle\\
&amp; = \frac{1}{\sqrt{2}} \vert +\rangle + \frac{1+i}{2} \vert -\rangle \\
&amp; = \biggl(\frac{1}{2} \vert 0\rangle + \frac{1}{2} \vert 1\rangle\biggr)
+ \biggl(\frac{1+i}{2\sqrt{2}} \vert 0\rangle - \frac{1+i}{2\sqrt{2}} \vert 1\rangle\biggr)\\
&amp; = \biggl(\frac{1}{2} + \frac{1+i}{2\sqrt{2}}\biggr) \vert 0\rangle
+ \biggl(\frac{1}{2} - \frac{1+i}{2\sqrt{2}}\biggr) \vert 1\rangle.
\end{aligned}
\end{split}\]</div>
<p>2 つのアプローチ — 明示的に行列表現に変換する方法と、線形性を使用して標準基底状態での演算の動作をプラグインする方法 — は同等です。その時々の状況に応じて、使いやすいほうを使えばいいのです。</p>
</section>
<section id="id17">
<h4>量子ビットユニタリー演算の合成<a class="headerlink" href="#id17" title="Link to this heading">#</a></h4>
<p>ユニタリー演算の合成は、確率論の設定で行ったのと同じように、行列の乗算で表されます。たとえば、最初にアダマール演算を適用し、次に <span class="math notranslate nohighlight">\(S\)</span> 演算を適用し、さらに別のアダマール演算を適用すると、結果の演算 (<span class="math notranslate nohighlight">\(R\)</span> と名付けます) は次のようになります。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  R = H S H =
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  \begin{pmatrix}
    1 &amp; 0\\
    0 &amp; i
  \end{pmatrix}
  \begin{pmatrix}
    \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\[2mm]
    \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
  \end{pmatrix}
  =
  \begin{pmatrix}
    \frac{1+i}{2} &amp; \frac{1-i}{2} \\[2mm]
    \frac{1-i}{2} &amp; \frac{1+i}{2}
  \end{pmatrix}.
\end{split}\]</div>
<p>このユニタリー演算 <span class="math notranslate nohighlight">\(R\)</span> は興味深い例です。この演算を 2 回適用することで、行列表現を 2 乗することと同等であり、NOT 演算が得られます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  R^2 = 
  \begin{pmatrix}
    \frac{1+i}{2} &amp; \frac{1-i}{2} \\[2mm]
    \frac{1-i}{2} &amp; \frac{1+i}{2}
  \end{pmatrix}^2
  =
  \begin{pmatrix}
    0 &amp; 1 \\[2mm]
    1 &amp; 0
  \end{pmatrix}.
\end{split}\]</div>
<p>つまり、<span class="math notranslate nohighlight">\(R\)</span> は <em>NOT 演算の平方根</em> です。同じ演算を 2 回適用して NOT 演算を生成するこのような動作は、単一ビットに対する従来の演算では不可能です。これは、負の数の平方根が実数の線上に留まることはできないという事実に関連しています。</p>
<p>以下の対話型コンポーネントを使用して、一連の量子ビット ユニタリー演算を作成できます。結果のユニタリー演算の行列表現と、状態 <span class="math notranslate nohighlight">\(\vert 0\rangle\)</span> （量子ビットのデフォルトの初期化状態）に対するその動作の両方を示しています。シーケンスを指定するには、量子ビットに実行する演算を下の行にドラッグします。一番左の演算が最初に適用され、一番右の演算が最後に適用されます。この図は <em>量子回路</em> を表しており、授業 3 でその詳細と一般性について説明します。</p>
</section>
<section id="id18">
<h4>大規模システムでのユニタリー演算<a class="headerlink" href="#id18" title="Link to this heading">#</a></h4>
<p>この後の授業では、2 つ以上の古典的な状態を持つシステムでのユニタリー演算の例を多く見ていきます。 3 つの古典的な状態を持つシステムでのユニタリー演算の例は、次の行列によって与えられます。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  A = 
  \begin{pmatrix}
    \class{_u00}{0} &amp; \class{_u10}{0} &amp; \class{_u20}{1} \\
    \class{_u01}{1} &amp; \class{_u11}{0} &amp; \class{_u21}{0} \\
    \class{_u02}{0} &amp; \class{_u12}{1} &amp; \class{_u22}{0}
  \end{pmatrix}
\end{split}\]</div>
<p>システムの古典的な状態が <span class="math notranslate nohighlight">\(0\)</span> 、 <span class="math notranslate nohighlight">\(1\)</span> 、および <span class="math notranslate nohighlight">\(2\)</span> であると仮定すると、この操作は <span class="math notranslate nohighlight">\(3\)</span> を法とする加算として記述できます。</p>
<div class="math notranslate nohighlight">
\[
  A \vert 0\rangle = \vert 1\rangle,
  \quad
  A \vert 1\rangle = \vert 2\rangle,
  \quad\text{and}\quad
  A \vert 2\rangle = \vert 0\rangle
\]</div>
<p>行列 <span class="math notranslate nohighlight">\(A\)</span> は <em>置換行列</em> の例です。これは、すべての行と列に <span class="math notranslate nohighlight">\(1\)</span>が 1 つだけ含まれる行列です。このような行列は、作用するベクトルのエントリを再配置または置換するだけです。単位行列は最も単純な置換行列です。もう 1 つの例は、ビットまたは量子ビットに対する NOT 操作です。すべての置換行列は、任意の正の整数次元でユニタリーです。これらは、古典演算と量子演算の両方を表す行列の唯一の例です。行列は、置換行列である場合に限り、確率論的かつユニタリーです。</p>
<p>ユニタリー行列の別の例、 <span class="math notranslate nohighlight">\(4\times 4\)</span> 行列は次のとおりです。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  U = 
  \frac{1}{2}
  \begin{pmatrix}
    1 &amp; 1 &amp; 1 &amp; 1 \\
    1 &amp; i &amp; -1 &amp; -i \\
    1 &amp; -1 &amp; 1 &amp; -1 \\
    1 &amp; -i &amp; -1 &amp; i
  \end{pmatrix}.
\end{split}\]</div>
<p>この行列は、特に <span class="math notranslate nohighlight">\(4\times 4\)</span> の場合の <em>量子フーリエ変換</em> として知られる操作を表しています。量子フーリエ変換は、任意の正の整数次元 <span class="math notranslate nohighlight">\(n\)</span> に対してより一般的に定義でき、量子アルゴリズムのユニット 2 で重要な役割を果たします。</p>
</section>
</section>
</section>
<section id="qiskit">
<h2>3. Qiskit コード例<a class="headerlink" href="#qiskit" title="Link to this heading">#</a></h2>
<p>このセクションでは、この授業で紹介した概念の Qiskit 実装の例をいくつか紹介します。</p>
<section id="python">
<h3>3.1 Python でのベクトルと行列<a class="headerlink" href="#python" title="Link to this heading">#</a></h3>
<p>Qiskit は Python プログラミング言語を使用するため、Qiskit について具体的に説明する前に、Python での行列とベクトルの計算について簡単に説明しておくと役立つ場合があります。 Python では、 <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> ライブラリー (数値計算用の多くの追加コンポーネントが含まれています) の <code class="docutils literal notranslate"><span class="pre">array</span></code> クラスを使用して、行列とベクトルの計算を実行できます。</p>
<p>以下は、量子ビット状態ベクトル <span class="math notranslate nohighlight">\(\vert 0\rangle\)</span> と <span class="math notranslate nohighlight">\(\vert 1\rangle\)</span> に対応する 2 つのベクトル <code class="docutils literal notranslate"><span class="pre">ket0</span></code> と <code class="docutils literal notranslate"><span class="pre">ket1</span></code> を定義し、それらの平均を表示するコード セルの例です。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>

<span class="n">ket0</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">ket1</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">display</span><span class="p">(</span><span class="n">ket0</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ket1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.5, 0.5])
</pre></div>
</div>
</div>
</div>
<p>実際には、この計算の結果を表示するために明示的に <code class="docutils literal notranslate"><span class="pre">display</span></code> コマンドを使用する必要はありません。代わりに、目的の式をコード セルの最後の行として単純に記述し、その出力として返されます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ket0</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ket1</span><span class="o">/</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.5, 0.5])
</pre></div>
</div>
</div>
</div>
<p>このコード セルは、このテキストブックの特定のページでコード セルを連続して実行すると累積的な効果があることも示しているため、  <code class="docutils literal notranslate"><span class="pre">array</span></code> クラスを再読み込みしたり、  <code class="docutils literal notranslate"><span class="pre">ket0</span></code> と <code class="docutils literal notranslate"><span class="pre">ket1</span></code> を再度定義したりする必要はありません。ただし、ページをリロードしたり、別のページに切り替えたりすると、すべてが初期状態にリセットされます。</p>
<p>一般的なガイドラインとして、このコースの番号が付けられた各サブセクション内のコード セルは、順番に実行されることを意図しています。そのため、コード セルを実行してエラーが発生する場合は、そのコード セルが表示されるサブセクション内の以前のすべてのコード セルを先に最初から実行してください。</p>
<p><code class="docutils literal notranslate"><span class="pre">array</span></code> を使用して、操作を表す行列を作成することもできます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">M1</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">M1</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">M2</span><span class="o">/</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1. , 1. ],
       [0.5, 0. ]])
</pre></div>
</div>
</div>
</div>
<p>行列の乗算 (特殊なケースとして行列とベクトルの乗算を含む) は、  <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> の <code class="docutils literal notranslate"><span class="pre">matmul</span></code> 関数を使用して実行できます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">matmul</span>

<span class="n">display</span><span class="p">(</span><span class="n">matmul</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="n">ket1</span><span class="p">))</span>
<span class="n">display</span><span class="p">(</span><span class="n">matmul</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="n">M2</span><span class="p">))</span>
<span class="n">display</span><span class="p">(</span><span class="n">matmul</span><span class="p">(</span><span class="n">M2</span><span class="p">,</span><span class="n">M1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1, 0])
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[2, 1],
       [0, 0]])
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1, 1],
       [1, 1]])
</pre></div>
</div>
</div>
</div>
</section>
<section id="id19">
<h3>3.2 Qiskit での状態、測定、および操作<a class="headerlink" href="#id19" title="Link to this heading">#</a></h3>
<p>Qiskit には、状態、測定、および操作を簡単に作成および操作できるいくつかのクラスが含まれています。したがって、ゼロから始めて、Python で量子状態、測定、および操作をシミュレートするために必要なすべてをプログラミングする必要はありません。開始するためのいくつかの例を以下に示します。</p>
<section id="id20">
<h4>状態ベクトルの定義と表示<a class="headerlink" href="#id20" title="Link to this heading">#</a></h4>
<p>Qiskit の <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> クラスは、量子状態ベクトルを定義および操作するための機能を提供します。次のコード セルは <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> クラスをインポートし、それを使用していくつかのベクトルを定義します。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">Statevector</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">Statevector</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">Statevector</span><span class="p">([(</span><span class="mi">1</span><span class="o">+</span><span class="mf">2.</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">])</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Statevector</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;State vectors u, v, and w have been defined.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>State vectors u, v, and w have been defined.
</pre></div>
</div>
</div>
</div>
<p>(ベクトル <code class="docutils literal notranslate"><span class="pre">u</span></code> の平方根を計算するには、  <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> ライブラリーの <code class="docutils literal notranslate"><span class="pre">sqrt</span></code> 関数が必要であることに注意してください。)</p>
<p><code class="docutils literal notranslate"><span class="pre">Statevector</span></code> クラスは、次のコード セルが示すように、さまざまな視覚化のための <code class="docutils literal notranslate"><span class="pre">latex</span></code> および <code class="docutils literal notranslate"><span class="pre">text</span></code> オプションを含む、状態ベクトルを表示するための <code class="docutils literal notranslate"><span class="pre">draw</span></code> メソッドを提供します。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">))</span>
<span class="n">display</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\frac{\sqrt{2}}{2} |0\rangle+\frac{\sqrt{2}}{2} |1\rangle\]</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 0.33333333+0.66666667j,-0.66666667+0.j        ]
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Statevector</span></code> クラスには <code class="docutils literal notranslate"><span class="pre">is_valid</span></code> メソッドも含まれています。このメソッドは、指定されたベクトルが有効な量子状態ベクトルであるかどうか (つまり、ユークリッド ノルムが 1 に等しいかどうか) を確認します。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">is_valid</span><span class="p">())</span>
<span class="n">display</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">is_valid</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
</section>
<section id="statevector">
<h4><code class="docutils literal notranslate"><span class="pre">Statevector</span></code> を使用した測定のシミュレーション<a class="headerlink" href="#statevector" title="Link to this heading">#</a></h4>
<p>次に、  <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> クラスの <code class="docutils literal notranslate"><span class="pre">measure</span></code> メソッドを使用して、Qiskit で量子状態の測定をシミュレートする方法を見ていきます。</p>
<p>まず、量子ビット状態ベクトル <code class="docutils literal notranslate"><span class="pre">v</span></code> を作成して表示します。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">Statevector</span><span class="p">([(</span><span class="mi">1</span><span class="o">+</span><span class="mf">2.</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">])</span>
<span class="n">v</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[(\frac{1}{3} + \frac{2 i}{3}) |0\rangle- \frac{2}{3} |1\rangle\]</div>
</div>
</div>
<p>（注：コード セルは変更できます。必要に応じてベクトルの仕様を変更してください。または、右側のスクラッチパッドを使用してコード セルを試すこともできます。）</p>
<p>次に、  <code class="docutils literal notranslate"><span class="pre">measure</span></code> メソッドを実行して、標準基底の測定をシミュレートします。その測定の結果と測定後のシステムの新しい量子状態が返ってきます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">v</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(np.str_(&#39;1&#39;),
 Statevector([ 0.+0.j, -1.+0.j],
             dims=(2,)))
</pre></div>
</div>
</div>
</div>
<p>測定結果は確率的であるため、同じメソッドが異なる結果を返す可能性があります。これを確認するには、セルを数回実行してみてください。</p>
<p>上記で定義された特定のベクトル <code class="docutils literal notranslate"><span class="pre">v</span></code> の例では、  <code class="docutils literal notranslate"><span class="pre">measure</span></code> メソッドは、測定が行われた後の量子状態ベクトルを次のように定義します。</p>
<div class="math notranslate nohighlight">
\[
\frac{1 + 2i}{\sqrt{5}} \vert 0\rangle
\]</div>
<p>(<span class="math notranslate nohighlight">\(\vert 0\rangle\)</span> ではなく) または</p>
<div class="math notranslate nohighlight">
\[
- \vert 1\rangle
\]</div>
<p>(<span class="math notranslate nohighlight">\(\vert 1\rangle\)</span> ではなく)上記のようになり、測定結果によって異なります。どちらの場合も、実際にはこれらは同等です。一方が他方に単位円上の複素数を掛けたものに等しいため、 <em>グローバル位相が異なる</em> と言われています。この問題については、授業 3 で詳しく説明しますが、現時点では無視しても問題ありません。</p>
<p>余談ですが、 <code class="docutils literal notranslate"><span class="pre">measure</span></code> メソッドが無効な量子状態ベクトルに適用されると、 <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> はエラーを投げます。気が向いたら挑戦してみてください！</p>
<p><code class="docutils literal notranslate"><span class="pre">Statevector</span></code> には、システム上の任意の数の測定のシミュレーションを可能にする <code class="docutils literal notranslate"><span class="pre">sample_counts</span></code> メソッドも付属しています。たとえば、次のセルはベクトル <code class="docutils literal notranslate"><span class="pre">v</span></code> を <span class="math notranslate nohighlight">\(1000\)</span> 回測定した結果を示しており、(高い確率で)  <span class="math notranslate nohighlight">\(9\)</span> 回ごとに約 <span class="math notranslate nohighlight">\(5\)</span>回 <span class="math notranslate nohighlight">\(0\)</span> の結果となり (または <span class="math notranslate nohighlight">\(1000\)</span> の試行の約 <span class="math notranslate nohighlight">\(556\)</span>)、 <span class="math notranslate nohighlight">\(9\)</span> 回ごとに約 <span class="math notranslate nohighlight">\(4\)</span> 回の <span class="math notranslate nohighlight">\(1\)</span> の結果となります(または <span class="math notranslate nohighlight">\(1000\)</span> の試行で約 <span class="math notranslate nohighlight">\(444\)</span> 回) 。このセルは、結果を視覚化するための <code class="docutils literal notranslate"><span class="pre">plot_histogram</span></code> 関数も示しています。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>

<span class="n">statistics</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">sample_counts</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">statistics</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">statistics</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{np.str_(&#39;0&#39;): np.int64(551), np.str_(&#39;1&#39;): np.int64(449)}
</pre></div>
</div>
<img alt="../../_images/637ef0269d19305f5eeed025a203b275b818dffc3349e6f5c0ca64635ec81bc0.png" src="../../_images/637ef0269d19305f5eeed025a203b275b818dffc3349e6f5c0ca64635ec81bc0.png" />
</div>
</div>
<p><span class="math notranslate nohighlight">\(1000\)</span> の代わりにさまざまな数のサンプルを試すことは、試行回数が推定確率にどのように影響するかについての直感を養うのに役立つ場合があります。</p>
</section>
<section id="operator-statevector">
<h4><code class="docutils literal notranslate"><span class="pre">Operator</span></code> と <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> を使用した演算の実行<a class="headerlink" href="#operator-statevector" title="Link to this heading">#</a></h4>
<p>次の例のように、 <code class="docutils literal notranslate"><span class="pre">Operator</span></code> クラスを使用して Qiskit の状態ベクトルに対してユニタリー演算を定義して実行できます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">Operator</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">],[</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([[</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)],[</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]])</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="n">j</span><span class="p">]])</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,(</span><span class="mi">1</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]])</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">Statevector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>

<span class="n">v</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 0.85355339+0.35355339j,-0.35355339+0.14644661j]
</pre></div>
</div>
</div>
</div>
</section>
<section id="id21">
<h4>量子回路の先を見据えて<a class="headerlink" href="#id21" title="Link to this heading">#</a></h4>
<p>量子回路は授業 3 まで正式に導入されませんが、それでも、Qiskit の <code class="docutils literal notranslate"><span class="pre">QuantumCircuit</span></code> クラスを使用して量子ビットのユニタリー演算を構成する実験を行うことができます。特に、量子回路 (この場合、単一量子ビットに対して実行されるユニタリー演算のシーケンス) を次のように定義できます。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span>

<span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/7aae9c0c6f1efa63d1105a6257488f5597628f167e394fe6a5091f3c449f93ba.png" src="../../_images/7aae9c0c6f1efa63d1105a6257488f5597628f167e394fe6a5091f3c449f93ba.png" />
</div>
</div>
<p>演算操作は、図の左側から順に適用され、右側で終了します。最初に開始量子状態ベクトルを初期化し、次に一連の操作に従ってその状態を進化させましょう。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ket0</span> <span class="o">=</span> <span class="n">Statevector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">ket0</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
<span class="n">v</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[(0.8535533906 + 0.3535533906 i) |0\rangle+(-0.3535533906 + 0.1464466094 i) |1\rangle\]</div>
</div>
</div>
<p>最後に、この実験 (つまり、状態 <span class="math notranslate nohighlight">\(\vert 0\rangle\)</span> を準備し、回路によって表される演算のシーケンスを適用し、測定する) を 4000 回実行した結果をシミュレートしましょう。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">statistics</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">sample_counts</span><span class="p">(</span><span class="mi">4000</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">statistics</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/6a7fea74b3e3e1ba5f691e935ada5316e154b38667fe8b4bf3565163ab2d4c2b.png" src="../../_images/6a7fea74b3e3e1ba5f691e935ada5316e154b38667fe8b4bf3565163ab2d4c2b.png" />
</div>
</div>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./courses/basics"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">はじめに</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">1.古典情報<a id="single-systems-classical"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">1.1 古典的な状態と確率ベクトル <a id="classical-states"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">1.2 確率的状態の測定 <a id="classical-measure"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">1.3 古典的な演算 <a id="classical-operations"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">決定論的演算</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">確率演算と確率行列</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">確率演算の合成</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">2. 量子情報<a id="single-systems-quantum"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">2.1 量子状態ベクトル<a id="single-systems-quantum-states"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">量子ビット状態の例</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">他の系の量子状態</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">2.2 量子状態の測定 <a id="single-systems-quantum-measure"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">2.3 ユニタリー演算 <a id="single-systems-unitary"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">量子ビットへのユニタリー演算の重要な例</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">量子ビットユニタリー演算の合成</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">大規模システムでのユニタリー演算</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#qiskit">3. Qiskit コード例</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#python">3.1 Python でのベクトルと行列</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">3.2 Qiskit での状態、測定、および操作</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">状態ベクトルの定義と表示</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#statevector"><code class="docutils literal notranslate"><span class="pre">Statevector</span></code> を使用した測定のシミュレーション</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#operator-statevector"><code class="docutils literal notranslate"><span class="pre">Operator</span></code> と <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> を使用した演算の実行</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">量子回路の先を見据えて</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Quantum Tokyo
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright Quantum Tokyo 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>